#Crap
#inv.d.resistance <- max(ifelse(is.na(d.resistance),-Inf,d.resistance)) - d.resistance

#AFPTdata <- NA
#length(AFPTdata) <- 216000
#AFPTdata[as.numeric(names(AFPT))] <- AFPT
#firstAFPT <- raster.set.filename(g, "e:/documents2/Grid_data/FirstAFPTMap.asc")
#write <- raster.write.ascii(firstAFPT, AFPTdata, overwrite=T)

#firstrmapasc <- raster.set.filename(g, "e:/documents/Grid_data/FirstResistanceMap.asc")
#write <- raster.write.ascii(firstrmapasc, rm)

genetic.distance <- function(data)
{
	data <- na.omit(data)
	data <- subset(data,data[,3]!=0)
	accession.index <- unique(data[,1])
	marker.fragment <- paste(data[,2],data[,3],sep="-")
	marker.fragment.index <- unique(marker.fragment)
	i <- match(data[,1],accession.index)-1
	j <- match(marker.fragment,marker.fragment.index)-1
	x <- rep(1,times=length(data[,1]))
	Dim1 <- length(accession.index)
	Dim2 <- length(marker.fragment.index)
	data.matrix <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim1,Dim2)))
	data.matrix <- as(data.matrix,"dgCMatrix")
	marker.index <- unlist(strsplit(marker.fragment.index,"-"))[seq(from=1,to=length(marker.fragment.index)*2,by=2)]
	distance.matrix <- matrix(0,ncol=length(accession.index),nrow=length(accession.index))
	sum.total <- t(apply(data.matrix,1,function(x){tapply(x,marker.index,sum)}))
	data.matrix.logical <- Matrix(as.integer(as.logical(data.matrix)),ncol=ncol(data.matrix))
	onepercent <- length(accession.index)/100
	count <- 0
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")	
	for (i in 1:length(accession.index))
	{
		from <- t(t(data.matrix.logical) * data.matrix[i,])
		to <- t(t(data.matrix)*as.numeric(as.logical(data.matrix[i,])))
		sum.from <- t(apply(from,1,function(x){tapply(x,marker.index,sum)}))
		sum.to <- t(apply(to,1,function(x){tapply(x,marker.index,sum)}))
		distance.matrix[,i] <- apply(pmin(sum.from/(sum.total+0.0000001),sum.to/(sum.total+0.0000001)),1,mean)
		count <- count+1
		if(count>=onepercent) {cat("|"); count<-0}
	}
	cat("|","\n")
	distance.matrix <- t(distance.matrix * sqrt(1/diag(distance.matrix))) * sqrt(1/diag(distance.matrix))
	rownames(distance.matrix) <- as.character(accession.index)
	colnames(distance.matrix) <- as.character(accession.index)
	return(distance.matrix)
}

genetic.distance <- function(datain, method="shared.proportion") #Generic function that will call a distance function for each pair of accessions. It requires a dataframe of three columns: accession, marker, fragment length. It produces a full symmetric matrix. 
{
	data <- as.matrix(datain)
	acc <- unique(data[,1])
	numbacc <- length(acc)
	count <- 0
	totalloops <- (numbacc*numbacc)/2 - (numbacc/2)
	dd <- matrix(0, nrow = numbacc, ncol = numbacc) 
	for (i in 1:numbacc) 
	{
		d1 <- subset(data, data[,1] == acc[i])
		ii <- i + 1
		if (ii <= numbacc) 
		{
			for (j in ii:numbacc) 
			{
				d2 <- subset(data, data[,1] == acc[j])
				d <- get(paste("distance.",method,sep=""))(d1, d2)
				dd[j,i] <- d
				count <- count+1
			}
		}
	}
	rownames(dd) <- acc
	colnames(dd) <- acc
	dd <- as.dist(dd,diag = FALSE, upper = FALSE)
	return(dd)
}

distance <- function(data)
{
	distance.function.markers <- function(index.accession) 
	{
		distance.function.fragments <- function(index.accession,index.marker)
		{
			a.fragments <- data[,3][data[,1]==index.accession[1] & data[,2]==index.marker[1]]
			b.fragments <- data[,3][data[,1]==index.accession[2] & data[,2]==index.marker[2]]
			if (length(a.fragments)>0 & length(b.fragments)>0)
			{
				a.shared.proportion.fragments <- length(a.fragments %in% intersect(a.fragments,b.fragments))/length(a.fragments)
				b.shared.proportion.fragments <- length(b.fragments %in% intersect(a.fragments,b.fragments))/length(b.fragments)
				shared.proportion.fragments <- min(a.shared.proportion.fragments,b.shared.proportion.fragments)
			}
			else {shared.proportion.fragments <- 0}
			return(shared.proportion.fragments)
		}
		markers <- unique(c(data[,2][data[,1]==index.accession[1]],data[,2][data[,1]==index.accession[2]]))
		shared.proportion.mean.markers  <- mean(apply(cbind(rep(index.accession,times=length(markers))),1,function(x){distance.function.fragments(x[1:2],x[3])}))
		return(shared.proportion.mean.markers)
	}
	data <- na.omit(data)
	data <- subset(data,data[,3]>0)	
	accession.numbers <- unique(data[,1])
	index.accession <- cbind(rep(as.character(accession.numbers), each=length(accession.numbers)),rep(as.character(accession.numbers), times=length(accession.numbers)))
	distance.matrix <- matrix(0,ncol=length(accession.numbers),nrow=length(accession.numbers))
	rownames(distance.matrix) <- as.character(accession.numbers)
	colnames(distance.matrix) <- as.character(accession.numbers)
	distance.matrix[index.accession] <- distance.function.markers(apply(index.accession,1,distance.function.markers))
	return(distance.matrix)
}
			
distance.shared.proportion <- function(a,b)
{
	a <- as.data.frame(cbind(a[,2:3],rep(TRUE,times=length(a[,1]))))
	colnames(a)<-c("marker","fragment","a")
	b <- as.data.frame(cbind(b[,2:3],rep(TRUE,times=length(b[,1]))))
	colnames(b)<-c("marker","fragment","b")
	joined <- merge(a,b,all=T)
	joined <- cbind(joined,apply(joined[,3:4],1,function(x){min(x[1],x[2])}))
	agreement <- tapply(joined[,5],joined[,1],function(x){sum(x,na.rm=T)})
	proportion.a <- ifelse(agreement>0,agreement/tapply(as.logical(joined[,3]),joined[,1],function(x){sum(x,na.rm=T)}),0)
	proportion.b <- ifelse(agreement>0,agreement/tapply(as.logical(joined[,4]),joined[,1],function(x){sum(x,na.rm=T)}),0)
	shP <- (mean(pmin(proportion.a,proportion.b)))
	return(shP)
}

getformula <- function (vars, dummy) #Obsolete now
{
	v <- vector(length = 0, mode = "character")	
	for (i in 2:length(vars)) 
	{
		if (dummy[i-1] == 1) 
		{
			v <- c(v,vars[i]) 
		}
	}	
	f <- paste(vars[1], " ~ ",paste(v, collapse = " + "))
	return(as.formula(f))	
}

permregression.residual <- function (forml, permutations = 99) #Based on ter Braak
{
	forml <- as.formula(forml)
	reference.summary <- summary(lm(forml))
	N <- attributes(as.dist(get(as.character(forml[[2]]))))$Size	#rownames(attr(terms(forml,keep.order = TRUE), "factors"))[1]
	residuals <- reference.summary$residuals
	formterms <- rownames(attr(terms(forml,keep.order = TRUE), "factors"))[2:length(rownames(attr(terms(forml), "factors")))] #TODO: forml[[3]] would also do, I think
	begincoeff <- 2*(length(formterms)+1)+2
	endcoeff <- 3*(length(formterms)+1)	
	statistic <- c(reference.summary$r.squared,abs(reference.summary$coefficients[begincoeff:endcoeff])) #Reference statistic
	perm <- matrix(0, nrow = permutations, ncol = (length(formterms)+1))
	permformula <- as.formula(paste("permvec ~",paste(formterms, collapse="+"))) #
	for (i in 1:permutations) 
	{
		take <- sample(N,N)
		permvec <- as.dist(as.matrix(residuals)[take, take])
		permutation.summary <- summary(lm(permformula))
		perm[i,] <- as.vector(c(permutation.summary$r.squared,abs(permutation.summary$coefficients[begincoeff:endcoeff]))) #Reports the R2 and partial t's for each lm permutation
	}
	signif <- (rowSums(apply(perm,1,function(x){x>statistic}))+1)/(permutations+1)  #The "+1"s of the formula are due to Hope (1968) who added the reference value itself to the distribution to make the test slightly more "conservative" (Legendre et al. 1994). TODO use apply
	result <- list(permutations=permutations,r.squared=statistic[1],significance.r=signif[1],significance.terms=signif[2:length(signif)])
	return(result)
}

gsr <- function(Source, Search, Replace) #global search and replace (a normal replace doesn't work for dataframes) found on http://tolstoy.newcastle.edu.au/R/help/06/07/30503.html
{ 
	Changed <- as.character(Source) 
	for (i in 1:length(Search)) 
	{ 
		Changed <- replace(Changed, Changed == Search[i], Replace[i])   
	} 
	return(Changed) 
}

markerid <- as.vector(unique(genedata[,2]))
numberofmarkers <- length(markerid)
newmarkerid <- as.vector(c(1:numberofmarkers))
genedata[,2] <- gsr(genedata[,2], markerid, newmarkerid)

distmarker.test <- function(datain) #Generic function that will call a distance function for each pair of accessions. It requires a dataframe of three columns: accession, marker, fragment length. It produces a full symmetric matrix. 
{
	data <- as.matrix(datain)
	acc <- unique(data[,1])
	numbacc <- length(acc)
	count <- 0
	totalloops <- (numbacc*numbacc)/2 - (numbacc/2)
	dd <- matrix(0, nrow = numbacc, ncol = numbacc) 
	d1 <- subset(data, data[,1] == acc[1])
	d2 <- subset(data, data[,1] == acc[2])
	dd <- list(d1,d2)
	return(dd)
}

distsharedProportion <- function(a, b) #This calculates the -ln(shared proportion of alleles) based on the algorithm explained in the microsat programme
{
	spmarker <- 0
	markersa <- unique(a[,2])
	markersb <- unique(b[,2])
	markers <- intersect(markersa,markersb)
	markers <- subset(markers,markers>0) #This filters out missing markers, because they are set to -99
	for (d in 1:length(markers)) 
	{
		#Create two vectors with all fragments for one accession for one marker
		fragmentsa <- subset(a[,3], a[,2] == markers[d])
		fragmentsb <- subset(b[,3], b[,2] == markers[d])
		if (length(subset(fragmentsa,fragmentsa>0))>0 & length(subset(fragmentsb,fragmentsb>0))>0) #Filter out null/missing alleles
		{
			#Create a vector with the unique fragments from the total set of fragments from the two accessions
			fragments <- unique(c(fragmentsa,fragmentsb))
			fragments <- subset(fragments, fragments>0) #Null and missing alleles are not counted as contributing to similarity
			numberoffragments <- length(fragments)
			#Create two vectors that will be filled by the frequencies of the unique fragments
			fragmentfra <- vector(mode = "integer", length = numberoffragments)
			fragmentfrb <- vector(mode = "integer", length = numberoffragments)
			for (i in 1:numberoffragments) #For each fragment, calculate the number of times it is present in a and b respectively
			{
				for (k in 1:length(fragmentsa))
				{
					if (fragments[i] == fragmentsa[k]) {fragmentfra[i] <- fragmentfra[i]+(1/length(fragmentsa))}
				}
				for (l in 1:length(fragmentsb))
				{
					if (fragments[i] == fragmentsb[l]) {fragmentfrb[i] <- fragmentfrb[i]+(1/length(fragmentsb))}
				}
			}
			for (m in 1:numberoffragments) 	#Take the minimum of the relative frequency of each fragment and add them
			{
				spmarker <- spmarker+min(fragmentfra[m],fragmentfrb[m])
			}
		}
		#else {cat("Marker ", markers[d], " has missing values.","\n")}
	}
	sp <- (spmarker/length(markers))/(1-(spmarker/length(markers)))	#Divide accumulated shared proportion by the number of markers
	return(sp)
}

distsharedProportion3 <- function(a, b) #This calculates the -ln(shared proportion of alleles) based on the algorithm explained in the microsat programme
{
	spmarker <- 0
	nomarkers <- 0
	markers <- intersect(unique(a[,2]),unique(b[,2]))
	markers <- subset(markers,markers>0) #This filters out missing markers, because they are set to -99
	for (d in 1:length(markers)) 
	{
		#Create two vectors with all fragments for one accession for one marker
		
		fragmentsa <- subset(a[,3], a[,2] == markers[d] & a[,3]>0)
		fragmentsb <- subset(b[,3], b[,2] == markers[d] & b[,3]>0)
		if (length(fragmentsa)>0 & length(fragmentsb)>0)
		{
			#Create a vector with the unique fragments from the total set of fragments from the two accessions
			fragments <- intersect(fragmentsa,fragmentsb)
			if (length(fragments) > 0)
			{
				spmarker <- spmarker + sum(pmin(tabulate(match(fragmentsa, fragments))*1/length(fragmentsa),tabulate(match(fragmentsb, fragments))*1/length(fragmentsb))) 
			}
			nomarkers <- nomarkers + 1
		}
	}
	#else {cat("Marker ", markers[d], " has missing values.","\n")}
	sp <- (spmarker/nomarkers) #make linear by adding: /(1-(spmarker/nomarkers))	#Divide accumulated shared proportion by the number of markers
	return(sp)
}

connectedbuffer <- function(grid,adjacency,startvalue,factor,limit) #TODO Integrate "connected buffer" and "adjacencygrid"
{
	u <- unique(adjacency[,1]) #adjacency is a dense matrix containing all adjacency combinations twice (symmetric)
	select <- rbind(u, tabulate(match(adjacency[,1], u)))
	select <- subset(select[1,],select[2,]<4)
	growthborder <- unique(adjacency[,1][adjacency[,1] %in% select]) #selects cells on the coast 
	behindgrowthborder <- unique(adjacency[,2][adjacency[,1] %in% select]) #select cells behind the coast, to avoid growing towards land later on
	remove(select); remove(u)
	new <- matrix(nrow=4*length(growthborder),ncol=2)
	border <- unique(c(seq(1,(grid@ncols*grid@nrows-grid@ncols+1),by=grid@ncols),seq(grid@ncols,grid@ncols*grid@nrows,by=grid@ncols),1:grid@ncols,seq(grid@ncols*grid@nrows-grid@ncols+1,grid@ncols*grid@nrows,by=1)))
	for (i in 1:limit)
	{
		new[,1] <- rep(growthborder, times=4)
		new[,2] <- c((growthborder+1),(growthborder-1),(growthborder+grid@ncols),(growthborder-grid@ncols))
		new <- subset(new, new[,2] %in% setdiff(new[,2],c(growthborder,behindgrowthborder,border))) #Border (and land) nodes are excluded. This leaves the border free, but users may want to connect the borders. This can be achieved by inserting these connections separately.
		newcells <- unique(new[,2])
		mutual <- matrix(nrow=4*length(newcells),ncol=2)
		mutual[,1] <- rep(newcells, times=4)
		mutual[,2] <- c((newcells+1),(newcells-1),(newcells+grid@ncols),(newcells-grid@ncols))
		mutual <- subset(mutual, mutual[,2] %in% newcells)
		value <- rep(startvalue/factor^(i-1), times=length(mutual[,1])+length(new[,1]))
		buffer <- as.matrix(rbind(buffer,as.matrix(cbind(rbind(new,mutual),value))))
		behindgrowthborder <- growthborder
		growthborder <- newcells
		remove(new); remove(newcells)
		new <- matrix(nrow=length(growthborder)*4,ncol=2)
	}
	buffer <- na.omit(buffer)
	buffer <- rbind(buffer,cbind(buffer[,2],buffer[,1],buffer[,3]))
	buffer <- unique(buffer)
	return(buffer)
}

permregression.old <- function (forml, permutations = 99) #Based on Pierre Legendre, Francois-Joseph Lapointe and Philippe Casgrain. 1994. Modeling brain evolution from behavior: A permutational regression approach. Evolution 48(5),1487-1499)
{
	forml <- as.formula(forml)
	a <- summary(lm(forml))
	formterms <- rownames(attr(terms(forml,keep.order = TRUE), "factors"))[2:length(rownames(attr(terms(forml), "factors")))] #TODO: forml[[3]] would also do, I think
	begincoeff <- 2*(length(formterms)+1)+2
	endcoeff <- 3*(length(formterms)+1)	
	statistic <- c(a$r.squared,abs(a$coefficients[begincoeff:endcoeff])) #Reference statistic
	y <- as.dist(get(rownames(attr(terms(forml,keep.order = TRUE), "factors"))[1]))
	N <- attributes(y)$Size
	perm <- matrix(0, nrow = permutations, ncol = (length(formterms)+1))
	signif <- vector(length = length(formterms)+1)
	permformula <- as.formula(paste("permvec ~",paste(formterms, collapse="+"))) #
	for (i in 1:permutations) 
	{
		take <- sample(N,N)
		permvec <- as.dist(as.matrix(y)[take, take])
		a <- summary(lm(permformula))
		perm[i,] <- as.vector(c(a$r.squared,abs(a$coefficients[begincoeff:endcoeff]))) #Reports the R2 and partial t's for each lm permutation
	}
	for (j in 1:(length(formterms)+1)) #Calculate significance of R2 and t for each var.
	{
		signif[j] <- (length(perm[,j][perm[,j] >= statistic[j]]) + 1) /(permutations+1) #The "+1"s of the formula are due to Hope (1968) who added the reference value itself to the distribution to make the test slightly more "conservative" (Legendre et al. 1994). TODO use apply
	}
	result <- list(permutations=permutations,r.squared=statistic[1],significance.r=signif[1],significance.terms=signif[2:length(signif)])
	return(result)
}

Laplacian <- function(A) #This function works around the limitation of matrices with Dim > 46340.
{
	i <- 0:(A@Dim[1]-1)
	j <- 0:(A@Dim[1]-1)
	x <- colSums(A)
	Dim <- A@Dim[1]
	D <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	L <- D-A
	return(as(L,"symmetricMatrix"))
}