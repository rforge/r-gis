#FUNCTIONS

min.distance.accumulation <- function(gendistance,nsimulations)
{
	gendistance <- as.matrix(gendistance)
	nsamples <- length(gendistance[,1])
	index <- cbind(rep(1:nsamples, times=nsamples),rep(1:nsamples, each=nsamples))
	index1 <- subset(index,index[,1]<=index[,2])
	index2 <- subset(index,index[,1]>index[,2])
	min.distance.accumulation <- matrix(nrow=nsimulations,ncol=nsamples)
	for (i in 1:nsimulations)
	{
		order <- sample(nsamples)
		gendistance.reordered <- gendistance[order,order]
		gendistance.reordered[index1] <- max(gendistance)+1
		gendistance.reordered[1,1] <- 0
		min.distance <- apply(gendistance.reordered,1,min)
		min.distance.accumulation.matrix <- matrix(min.distance,nrow=length(min.distance),ncol=length(min.distance))
		min.distance.accumulation.matrix[index2] <- 0
		min.distance.accumulation[i,] <- colSums(min.distance.accumulation.matrix)
	}
	return(colSums(min.distance.accumulation)/nsimulations)
}

min.mean.proportion.per.lag <- function(gendistance,geodistance,lags,nsimulations)
{
	gendistance <- as.matrix(gendistance)
	diag(gendistance) <- max(gendistance+1)
	proportions <- vector(length=length(lags))
	lags <- c(0,lags,max(geodistance))
	for (i in 1:length(lags)+1)
	{
		means.proportions <- vector(length=length(gendistance[,1]))
		n.inside.radius <- vector(length=length(gendistance[,1]))
		for (n in 1:length(gendistance[,1]))
		{
			gendistance.selection <- subset(gendistance[,n],(geodistance.selection>lag[i] & geodistance.selection<lag[i+1])) 
			if (length(gendistance.selection)>2)
			{
				x <- 1:(length(gendistance.selection[,1]))
				mda <- min.distance.accumulation(gendistance.selection,nsimulations)
				means.proportions[n] <- coef(nls(mda ~ x^pow, start = c(pow=0.9), alg = 'plinear', trace = TRUE))[1]
				n.inside.radius[n] <- length(gendistance.selection)
			}
		else {proportions[n]<- -99}
		}	
	}
	return(proportions)
}
