#FUNCTIONS

min.distance.accumulation <- function(gendistance,nsimulations)
{
	gendistance <- as.matrix(gendistance)
	nsamples <- length(gendistance[,1])
	index <- cbind(rep(1:nsamples, times=nsamples),rep(1:nsamples, each=nsamples))
	index1 <- subset(index,index[,1]<=index[,2])
	index2 <- subset(index,index[,1]>index[,2])
	min.distance.accumulation <- matrix(nrow=nsimulations,ncol=nsamples)
	for (i in 1:nsimulations)
	{
		order <- sample(nsamples)
		gendistance.reordered <- gendistance[order,order]
		gendistance.reordered[index1] <- max(gendistance)+1
		gendistance.reordered[1,1] <- 0
		min.distance <- apply(gendistance.reordered,1,min)
		min.distance.accumulation.matrix <- matrix(min.distance,nrow=length(min.distance),ncol=length(min.distance))
		min.distance.accumulation.matrix[index2] <- 0
		min.distance.accumulation[i,] <- colSums(min.distance.accumulation.matrix)
	}
	return(colSums(min.distance.accumulation)/nsimulations)
}

power.model <- function(min.distance.accumulation)
{
	x <- 1:length(min.distance.accumulation)
	parameters <- coef(nls(min.distance.accumulation ~ x^pow, start = c(pow=0.9), alg = 'plinear', trace = TRUE))
	return(parameters)
}

cluster.parameters <- function(gendistance,nsimulations)
{
	parameters.per.k <- matrix(nrow=4,ncol=length(as.matrix(gendistance)[,1]))
	for (k in 1:length(as.matrix(gendistance)[,1]))
	{
		hcl<-hclust(gendistance)
		clusters <- cutree(hcl,k=k)
		parameters.per.cluster <- matrix(nrow=2,ncol=max(clusters))
		for (cluster in 1:max(clusters))
		{
			selection <- names(clusters[clusters==cluster])
			mda <- min.distance.accumulation(as.matrix(gendistance)[selection,selection],nsimulations)
			parameters.per.cluster[1:2,cluster] <- power.model(mda)
		}
		parameters.per.k[1:4,k] <- c(mean(parameters.per.cluster[1,]),sd(parameters.per.cluster[1,]),mean(parameters.per.cluster[2,]),sd(parameters.per.cluster[2,])) 
	}
return(parameters.per.k)
}

