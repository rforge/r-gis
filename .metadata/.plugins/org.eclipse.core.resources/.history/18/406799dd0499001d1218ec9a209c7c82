setGeneric("transition.create", function(raster, ..., transition.function, outer.meridian.connect) standardGeneric("transition.create"))

setMethod("transition.create", signature(raster = "raster"), def = function(raster, ..., transition.function, outer.meridian.connect=FALSE)
		{
			if(length(list(raster,...)==1))
			{
				transition <- new("transition",nrows=raster@nrows,ncols=raster@ncols,xmin=raster@xmin,xmax=raster@xmax,ymin=raster@ymin,ymax=raster@ymax)
				adj <- adjacency(raster,outer.meridian.connect=outer.meridian.connect)
				transition.values <- apply(cbind(raster@data[adj[,1]],raster@data[adj[,2]]),1,transition.function)
				transition.dsC <- as(transition,"dsCMatrix")
				transition.dsC[adj] <- as.vector(transition.values)
				transition <- dsCMatrix.to.transition(transition.dsC,transition)
			}
			if(length(list(raster,...)>1))
			{
				rasters <- list(raster,...)
				for (i in 2:length(rasters))
				{
					if (identical(FALSE,all.equal(rasters[[i]]@nrows,raster@nrows)) | identical(FALSE,all.equal(rasters[[i]]@ncols,raster@ncols)) | identical(FALSE,all.equal(rasters[[i]]@xmin,raster@xmin)) | identical(FALSE,all.equal(rasters[[i]]@xmax,raster@xmax)) | identical(FALSE,all.equal(rasters[[i]]@ymin,raster@ymin)) | identical(FALSE,all.equal(rasters[[i]]@ymax,raster@ymax)))
					{}
					else {stop("rasters do not coincide")}
				}
				adj <- adjacency(rasters[[1]],outer.meridian.connect=outer.meridian.connect) 
				x <- matrix(ncol=1,nrow=raster@ncells)
				x[,1] <- as.integer(1:raster@ncells)
				for (i in 1:length(rasters)) 
				{
					x <- cbind(x,rasters[[i]]@data[x[,1]])
					x <- na.omit(x)
				}
				adj <- subset(adj, (adj[,1] %in% x[,1] & adj[,2] %in% x[,2]))
				x.minus.y <- x[adj[,1],]-x[adj[,2],]
				cov.inv <- solve(cov(x))
				mahaldistance <- apply(x.minus.y,1,function(x){sqrt((x%*%cov.inv)%*%x)})
				mahaldistance <- mean(mahaldistance)/(mahaldistance+mean(mahaldistance))
				transition.dsC <- new("dsCMatrix", 
						p = as.integer(rep(0,rasterstack@ncells+1)),
						Dim = as.integer(c(raster@ncells,raster@ncells)),
						Dimnames = list(1:raster@ncells,1:raster@ncells)
				)
				transition.dsC[adj] <- mahaldistance
				transition <- new("transition",nrows=raster@nrows,ncols=raster@ncols,xmin=raster@xmin,xmax=raster@xmax,ymin=raster@ymin,ymax=raster@ymax)
				transition <- dsCMatrix.to.transition(transition.dsC,transition)
			}
			return(transition)
	}
)

setGeneric("transition.create.from.rasterstack.mahal", function(rasterstack, outer.meridian.connect) standardGeneric("transition.create.from.rasterstack.mahal"))

setMethod("transition.create.from.rasterstack.mahal", signature(rasterstack = "rasterstack"), 
		def = function(rasterstack, outer.meridian.connect)
		{
			
		}
)




setClass(
		Class="rasterchar",
		representation = representation(
				projection="character",
				ncols ="integer",
				nrows ="integer",
				ncells ="integer",
				xmin ="numeric",
				xmax ="numeric",
				ymin ="numeric",
				ymax ="numeric",		
				xres ="numeric",
				yres ="numeric"
		),
		validity = function(object)
		{
			cond1 <- object@ncols*object@nrows == object@ncells
			cond2 <- isTRUE(all.equal(object@xres,(xmax-xmin)/ncols))
			cond3 <- isTRUE(all.equal(object@yres,(ymax-xmin)/nrows))
			cond <- cond1 & cond2 & cond3
			return(cond)
		}
)

setClass(
		Class="transition",
		representation = representation(
			zerorowcol = "logical",
			uplo = "character",
			p = "integer",
			i = "integer",
			x = "numeric",
			Dim = "integer",
			Dimnames = "list"
		),
		contains = "rasterchar",
		validity = function(object){
			if(zerorowcol == TRUE)
			{
				cond1 <- all(object@ncells, object@Dim[1], object@Dim[2]) 
				cond2 <- isTRUE(all.equal(object@xres , (object@xmax-object@xmin)/object@ncols))
				cond3 <- isTRUE(all.equal(object@yres , (object@ymax-object@ymin)/object@nrows))
				cond4 <- length(p) == Dim[1]+1
				cond <- cond1 & cond2 & cond3 & cond4
			}
			if (zerorowcol == FALSE)
			{
				cond1 <- length(object@Dimnames[[1]]) == object@Dim[1]
				cond2 <- length(object@Dimnames[[2]]) == object@Dim[2]
				cond3 <- Dim[1] == Dim[2]
				cond4 <- max(as.numeric(Dimnames[[1]]),as.numeric(Dimnames[[2]])) <= Dim[1]
				cond5 <- length(Dimnames[[1]]==Dim[1]) & length(Dimnames[[1]]==Dim[1])
				cond <- cond1 & cond2 & cond3 & cond4 & cond5
			}
			return(cond)
		}
)

setClass(
		Class="transitionstack",
		representation = representation(
			ntransitions = "integer",
			transitions = "list",
			zerorowcol = "logical"
		),
		contains = "rasterchar",
		validity = function(object){
			lengthrasters <- length(object@rasters)
			dimensions1 <- unlist(lapply(object@rasters,function(x){dim(x)[1]}))
			dimensions2 <- unlist(lapply(object@rasters,function(x){dim(x)[2]}))
			dimensions.equal <- all(dimensions==dimensions[1]) & all(dimensions2==dimensions2[1]) #TODO USE all.equal... Solidified transition allowed?
			if(lengthraster == nrasters & dimensions.equal) {cond <- TRUE} 
			else{cond <- FALSE}
			return(cond)
		}
)

setClass(
		Class="transitionstack",
		representation = representation(
				ntransitions = "integer",
				transitions = "list",
				zerorowcol = "logical"
		),
		contains = "rasterchar",
		validity = function(object){
			lengthrasters <- length(object@rasters)
			
			if(object@zerorowcol == TRUE)
			{
				dims <- unlist(lapply(object@transitions,dim))
				dimensions.equal <- all(dims==as.integer(object@ncells))
			}
			else{}
			if(object@zerorowcol == FALSE)
			{
				#TODO implement validity check
			}
			else{}	
			if((lengthraster == nrasters) & dimensions.equal) {cond <- TRUE} else {cond <- FALSE}
			return(cond)
		}
)

setMethod ("show" , "transition", 
		function(object) {
			cat("class     :" , class(object), "\n")
			cat("nrows     :" , object@nrows, "\n")
			cat("ncols     :" , object@ncols, "\n")
			cat("ncells    :" , object@ncells, "\n")
			cat("projection:" , object@projection, "\n")
			cat("xmin      :" , object@xmin, "\n")
			cat("xmax      :" , object@xmax, "\n")
			cat("ymin      :" , object@ymin, "\n")
			cat("ymax      :" , object@ymax, "\n")
			cat("xres      :" , object@xres, "\n")
			cat("yres      :" , object@yres, "\n")
			cat ("\n")
		}
)

setMethod ("initialize", "transition",
		function(.Object,nrows,ncols,xmin,xmax,ymin,ymax)
		{
			ncells = as.integer(nrows*ncols)
			.Object@zerorowcol = TRUE
			.Object@nrows = as.integer(nrows)
			.Object@ncols = as.integer(ncols)
			.Object@ncells = as.integer(ncells)
			.Object@xmin = xmin
			.Object@xmax = xmax
			.Object@ymin = ymin
			.Object@ymax = ymax
			.Object@xres = (xmax-xmin)/ncols
			.Object@yres = (ymax-ymin)/nrows
			.Object@uplo = "U"
			.Object@p = as.integer(rep(0,ncells+1))
			.Object@i = integer(0)
			.Object@Dim = as.integer(c(ncells,ncells))
			.Object@Dimnames = list(1:ncells,1:ncells)
			return(.Object)
		}
)

setAs(
			from="transition",
			to="dsCMatrix",
			def=function(from){
				to <- new("dsCMatrix",
					uplo = from@uplo,
					p = from@p,
					i = from@i,
					x = from@x,
					Dim = from@Dim,
					Dimnames = from@Dimnames
					)
				return(to)
			},
)

setGeneric("dsCMatrix.to.transition", function(dsCMatrix,transition) standardGeneric("dsCMatrix.to.transition"))

setMethod ("dsCMatrix.to.transition", signature(dsCMatrix = "dsCMatrix", transition = "transition"),
	function(dsCMatrix,transition){
		transition@uplo = dsCMatrix@uplo
		transition@p = dsCMatrix@p
		transition@i = dsCMatrix@i
		transition@x = dsCMatrix@x
		transition@Dim = dsCMatrix@Dim
		transition@Dimnames = dsCMatrix@Dimnames
		return(transition)
	}
)

setMethod("Arith", signature(e1 = "transition", e2 = "transition"),
		function(e1, e2){
			if(
			isTRUE(all.equal(e1@nrows,e2@nrows)) &
			isTRUE(all.equal(e1@ncols, e2@ncols)) &
			isTRUE(all.equal(e1@ncells, e2@ncells)) &
			isTRUE(all.equal(e1@projection, e2@projection)) &
			isTRUE(all.equal(e1@xmin, e2@xmin)) &
			isTRUE(all.equal(e1@xmax, e2@xmax)) &
			isTRUE(all.equal(e1@ymin, e2@ymin)) &
			isTRUE(all.equal(e1@ymax, e2@ymax)) &
			isTRUE(all.equal(e1@xres, e2@xres)) &
			isTRUE(all.equal(e1@yres, e2@yres)))
				{
					return(dsCMatrix.to.transition(callGeneric(as(e1,"dsCMatrix"),as(e2,"dsCMatrix")),e1))
				}
		}
)


if(func=="prod")
{
	for (i in 2:ntransitions)
	{
		tm.dsC <- tm.dsC*as(ts@transitions[[i]], "dsCMatrix")
	}
	tm <- new("transition",
			projection = ts@projection,
			ncols = ts@ncols,
			nrows = ts@nrows,
			ncells = ts@ncells,
			xmin = ts@xmin,
			xmax = ts@xmax,
			ymin = ts@ymin,
			ymax = ts@ymax,		
	)
	tm <- dsCMatrix.to.transition(tm.dsC,tm)
	return(tm)
}
else{stop("other methods not implemented yet")}
}
)




================================
		
		
		

setClass ("raster.new",
		representation (
				filename ="character",
				gdalhandle="list",
				rastername ="character",
				filetype ="character",
				datatype ="character",
				datasize ="integer",
				datasigned="logical",
				datanotation="character",
				byteorder ="character",
				valid ="logical",
				nbands ="integer",
				band = "integer",
				bandorder ="character",
				minvalue ="numeric",
				maxvalue ="numeric",
				nodatavalue ="numeric",
				data="array",
				datasource="character"
#		datablock="vector"
#		datamat ="matrix"
#		.data ="vector",
		),
		contains = "rasterchar",
		prototype (
				filename = "",
				gdalhandle= list(),
				rastername ="",
				filetype = "",
				datatype = "numeric",
				datasize = as.integer(4),
				datasigned= TRUE,
				datanotation="FLT4S",
				byteorder = .Platform$endian,
				valid = TRUE,
				projection= "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
				nbands = as.integer(1),
				band = as.integer(1),
				bandorder = "BSQ",
				ncols = as.integer(360),
				nrows = as.integer(180),
				ncells = as.integer(360 * 180),
				ncellvals = as.integer(360 * 180),
				xmin = -180,
				xmax = 180,
				ymin = -90,
				ymax = 90,
				xres =  1,
				yres =  1,
				minvalue = numeric (1),
				maxvalue = numeric (1),
				nodatavalue = -9999,
				data=array(NA,0),
				datasource=""
#		datablock=vector("integer", length=2)
		)
)