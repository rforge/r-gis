#FUNCTIONS

adjacency <- function(raster, outer.meridian.connect=FALSE) 
{
	cells <- c(1:raster@ncells)
	data <- cbind(cells, raster@data)
	datacells <- as.integer(na.omit(data)[,1])
	left <- seq(raster@ncols+1,(raster@ncols*raster@nrows-2*raster@ncols+1),by=raster@ncols) 
	right <- seq(2*raster@ncols,raster@ncols*raster@nrows-raster@ncols,by=raster@ncols)
	upper <- 2:(raster@ncols-1)
	lower <- seq((raster@ncols*raster@nrows-raster@ncols+2),(raster@ncols*raster@nrows-1),by=1)
	upperleft <- 1
	upperright <- raster@ncols
	lowerleft <- raster@ncols*raster@nrows-raster@ncols+1
	lowerright <- raster@ncols*raster@nrows
	datacells.core <- setdiff(datacells,(c(left,right,upper,lower,upperleft,upperright,lowerleft,lowerright)))
	datacells.upper <- intersect(datacells,upper)
	datacells.lower <- intersect(datacells,lower)	
	datacells.left <- as.integer(intersect(datacells,left))
	datacells.right <- as.integer(intersect(datacells,right))
	datacell.upperleft <- as.integer(intersect(datacells,upperleft))
	datacell.upperright <- as.integer(intersect(datacells,upperright))
	datacell.lowerleft <- as.integer(intersect(datacells,lowerleft))
	datacell.lowerright <- as.integer(intersect(datacells,lowerright))
	from.core <- as.integer(rep(datacells.core, times=4))
	to.core <- as.integer(c(datacells.core+1,datacells.core-1,datacells.core+raster@ncols,datacells.core-raster@ncols))
	from.upper <- as.integer(rep(datacells.upper, times=3))
	to.upper <- as.integer(c(datacells.upper+1,datacells.upper-1,datacells.upper+raster@ncols))
	from.lower <- as.integer(rep(datacells.lower, times=3))
	to.lower <- as.integer(c(datacells.lower+1,datacells.lower-1,datacells.lower-raster@ncols))
	from.left <- as.integer(rep(datacells.left, times=3))
	to.left <- as.integer(c(datacells.left+1,datacells.left+raster@ncols,datacells.left-raster@ncols))
	from.right <- as.integer(rep(datacells.right, times=3))
	to.right <- as.integer(c(datacells.right-1,datacells.right+raster@ncols,datacells.right-raster@ncols))
	from.upperleft <- as.integer(rep(datacell.upperleft, times=2))
	to.upperleft <- as.integer(c(datacell.upperleft+1,datacell.upperleft+raster@ncols))
	from.upperright <- as.integer(rep(datacell.upperright, times=2))
	to.upperright <- as.integer(c(datacell.upperright-1,datacell.upperright+raster@ncols))
	from.lowerleft <- as.integer(rep(datacell.lowerleft, times=2))
	to.lowerleft <- as.integer(c(datacell.lowerleft+1,datacell.lowerleft-raster@ncols))
	from.lowerright <- as.integer(rep(datacell.lowerright, times=2))
	to.lowerright <- as.integer(c(datacell.lowerright-1,datacell.lowerright-raster@ncols))
	fromto <- rbind(cbind(from.core,to.core),cbind(from.upper,to.upper),cbind(from.lower,to.lower),cbind(from.left,to.left),cbind(from.right,to.right),cbind(from.upperleft,to.upperleft),cbind(from.upperright,to.upperright),cbind(from.lowerleft,to.lowerleft),cbind(from.lowerright,to.lowerright))
	if (outer.meridian.connect==TRUE) 
	{
		mer.from.left <- rbind(cbind(datacells.left,as.integer(datacells.left+raster@ncols-1)),cbind(datacell.upperleft,as.integer(datacell.upperleft+raster@ncols-1)),cbind(datacell.lowerleft,as.integer(datacell.lowerleft+raster@ncols-1)))
		mer.from.right <- rbind(cbind(datacells.right,as.integer(datacells.right-raster@ncols+1)),cbind(datacell.upperright,as.integer(datacell.upperright-raster@ncols+1)),cbind(datacell.lowerright,as.integer(datacell.lowerright-raster@ncols+1)))
		fromto <- rbind(fromto,mer.from.left,mer.from.right)
	}
	fromto <- subset(fromto,fromto[,2] %in% datacells)
	colnames(fromto) <- c("from","to")
	return(fromto)
}

adjacency.buffer.from.raster <- function(raster, limit, outer.meridian.connect=FALSE)
{
	fromto.final <- matrix(ncol=3,nrow=0)
	newdatacells <- NULL
	cells <- c(1:raster@ncells)
	data <- cbind(cells, raster@data)
	datacells <- as.integer(na.omit(data)[,1])
	left <- seq(raster@ncols+1,(raster@ncols*raster@nrows-2*raster@ncols+1),by=raster@ncols) 
	right <- seq(2*raster@ncols,raster@ncols*raster@nrows-raster@ncols,by=raster@ncols)
	upper <- 2:(raster@ncols-1)
	lower <- seq((raster@ncols*raster@nrows-raster@ncols+2),(raster@ncols*raster@nrows-1),by=1)
	upperleft <- 1
	upperright <- raster@ncols
	lowerleft <- raster@ncols*raster@nrows-raster@ncols+1
	lowerright <- raster@ncols*raster@nrows
	for (i in 0:limit)
	{
		datacells.core <- setdiff(datacells,(c(left,right,upper,lower,upperleft,upperright,lowerleft,lowerright)))
		datacells.upper <- intersect(datacells,upper)
		datacells.lower <- intersect(datacells,lower)	
		datacells.left <- as.integer(intersect(datacells,left))
		datacells.right <- as.integer(intersect(datacells,right))
		datacell.upperleft <- as.integer(intersect(datacells,upperleft))
		datacell.upperright <- as.integer(intersect(datacells,upperright))
		datacell.lowerleft <- as.integer(intersect(datacells,lowerleft))
		datacell.lowerright <- as.integer(intersect(datacells,lowerright))
		from.core <- as.integer(rep(datacells.core, times=4))
		to.core <- as.integer(c(datacells.core+1,datacells.core-1,datacells.core+raster@ncols,datacells.core-raster@ncols))
		from.upper <- as.integer(rep(datacells.upper, times=3))
		to.upper <- as.integer(c(datacells.upper+1,datacells.upper-1,datacells.upper+raster@ncols))
		from.lower <- as.integer(rep(datacells.lower, times=3))
		to.lower <- as.integer(c(datacells.lower+1,datacells.lower-1,datacells.lower-raster@ncols))
		from.left <- as.integer(rep(datacells.left, times=3))
		to.left <- as.integer(c(datacells.left+1,datacells.left+raster@ncols,datacells.left-raster@ncols))
		from.right <- as.integer(rep(datacells.right, times=3))
		to.right <- as.integer(c(datacells.right-1,datacells.right+raster@ncols,datacells.right-raster@ncols))
		from.upperleft <- as.integer(rep(datacell.upperleft, times=2))
		to.upperleft <- as.integer(c(datacell.upperleft+1,datacell.upperleft+raster@ncols))
		from.upperright <- as.integer(rep(datacell.upperright, times=2))
		to.upperright <- as.integer(c(datacell.upperright-1,datacell.upperright+raster@ncols))
		from.lowerleft <- as.integer(rep(datacell.lowerleft, times=2))
		to.lowerleft <- as.integer(c(datacell.lowerleft+1,datacell.lowerleft-raster@ncols))
		from.lowerright <- as.integer(rep(datacell.lowerright, times=2))
		to.lowerright <- as.integer(c(datacell.lowerright-1,datacell.lowerright-raster@ncols))
		fromto <- rbind(cbind(from.core,to.core),cbind(from.upper,to.upper),cbind(from.lower,to.lower),cbind(from.left,to.left),cbind(from.right,to.right),cbind(from.upperleft,to.upperleft),cbind(from.upperright,to.upperright),cbind(from.lowerleft,to.lowerleft),cbind(from.lowerright,to.lowerright))
		if (outer.meridian.connect==TRUE) 
		{
			mer.from.left <- rbind(cbind(datacells.left,as.integer(datacells.left+raster@ncols-1)),cbind(datacell.upperleft,as.integer(datacell.upperleft+raster@ncols-1)),cbind(datacell.lowerleft,as.integer(datacell.lowerleft+raster@ncols-1)))
			mer.from.right <- rbind(cbind(datacells.right,as.integer(datacells.right-raster@ncols+1)),cbind(datacell.upperright,as.integer(datacell.upperright-raster@ncols+1)),cbind(datacell.lowerright,as.integer(datacell.lowerright-raster@ncols+1)))
			fromto <- rbind(fromto,mer.from.left,mer.from.right)
		}
		final.add <- subset(fromto,(fromto[,1] %in% newdatacells | fromto[,2] %in% newdatacells))
		final.add <- subset(final.add,(final.add[,1] %in% datacells & final.add[,2] %in% datacells))
		fromto.final <- rbind(fromto.final,cbind(final.add,rep(i,times=length(final.add[,1]))))
		newdatacells <- as.integer(intersect(setdiff(fromto[,2],datacells),cells))
		datacells <- c(datacells,newdatacells)
	}
	colnames(fromto.final) <- c("from","to","buffer")
	return(fromto.final)
}

adjacency.buffer.from.adjacency <- function(raster, adjacency, limit, outer.meridian.connect=FALSE)
{
	fromto.final <- matrix(ncol=3,nrow=0)
	newdatacells <- NULL 
	cells <- c(1:raster@ncells)
	datacells <- as.integer(unique(as.vector(adjacency)))
	left <- seq(raster@ncols+1,(raster@ncols*raster@nrows-2*raster@ncols+1),by=raster@ncols) 
	right <- seq(2*raster@ncols,raster@ncols*raster@nrows-raster@ncols,by=raster@ncols)
	upper <- 2:(raster@ncols-1)
	lower <- seq((raster@ncols*raster@nrows-raster@ncols+2),(raster@ncols*raster@nrows-1),by=1)
	upperleft <- 1
	upperright <- raster@ncols
	lowerleft <- raster@ncols*raster@nrows-raster@ncols+1
	lowerright <- raster@ncols*raster@nrows
	for (i in 0:limit)
	{
		datacells.core <- setdiff(datacells,(c(left,right,upper,lower,upperleft,upperright,lowerleft,lowerright)))
		datacells.upper <- intersect(datacells,upper)
		datacells.lower <- intersect(datacells,lower)	
		datacells.left <- as.integer(intersect(datacells,left))
		datacells.right <- as.integer(intersect(datacells,right))
		datacell.upperleft <- as.integer(intersect(datacells,upperleft))
		datacell.upperright <- as.integer(intersect(datacells,upperright))
		datacell.lowerleft <- as.integer(intersect(datacells,lowerleft))
		datacell.lowerright <- as.integer(intersect(datacells,lowerright))
		from.core <- as.integer(rep(datacells.core, times=4))
		to.core <- as.integer(c(datacells.core+1,datacells.core-1,datacells.core+raster@ncols,datacells.core-raster@ncols))
		from.upper <- as.integer(rep(datacells.upper, times=3))
		to.upper <- as.integer(c(datacells.upper+1,datacells.upper-1,datacells.upper+raster@ncols))
		from.lower <- as.integer(rep(datacells.lower, times=3))
		to.lower <- as.integer(c(datacells.lower+1,datacells.lower-1,datacells.lower-raster@ncols))
		from.left <- as.integer(rep(datacells.left, times=3))
		to.left <- as.integer(c(datacells.left+1,datacells.left+raster@ncols,datacells.left-raster@ncols))
		from.right <- as.integer(rep(datacells.right, times=3))
		to.right <- as.integer(c(datacells.right-1,datacells.right+raster@ncols,datacells.right-raster@ncols))
		from.upperleft <- as.integer(rep(datacell.upperleft, times=2))
		to.upperleft <- as.integer(c(datacell.upperleft+1,datacell.upperleft+raster@ncols))
		from.upperright <- as.integer(rep(datacell.upperright, times=2))
		to.upperright <- as.integer(c(datacell.upperright-1,datacell.upperright+raster@ncols))
		from.lowerleft <- as.integer(rep(datacell.lowerleft, times=2))
		to.lowerleft <- as.integer(c(datacell.lowerleft+1,datacell.lowerleft-raster@ncols))
		from.lowerright <- as.integer(rep(datacell.lowerright, times=2))
		to.lowerright <- as.integer(c(datacell.lowerright-1,datacell.lowerright-raster@ncols))
		fromto <- rbind(cbind(from.core,to.core),cbind(from.upper,to.upper),cbind(from.lower,to.lower),cbind(from.left,to.left),cbind(from.right,to.right),cbind(from.upperleft,to.upperleft),cbind(from.upperright,to.upperright),cbind(from.lowerleft,to.lowerleft),cbind(from.lowerright,to.lowerright))
		if (outer.meridian.connect==TRUE) 
		{
			mer.from.left <- rbind(cbind(datacells.left,as.integer(datacells.left+raster@ncols-1)),cbind(datacell.upperleft,as.integer(datacell.upperleft+raster@ncols-1)),cbind(datacell.lowerleft,as.integer(datacell.lowerleft+raster@ncols-1)))
			mer.from.right <- rbind(cbind(datacells.right,as.integer(datacells.right-raster@ncols+1)),cbind(datacell.upperright,as.integer(datacell.upperright-raster@ncols+1)),cbind(datacell.lowerright,as.integer(datacell.lowerright-raster@ncols+1)))
			fromto <- rbind(fromto,mer.from.left,mer.from.right)
		}
		final.add <- subset(fromto,(fromto[,1] %in% newdatacells | fromto[,2] %in% newdatacells))
		final.add <- subset(final.add,(final.add[,1] %in% datacells & final.add[,2] %in% datacells))
		fromto.final <- rbind(fromto.final,cbind(final.add,rep(i,times=length(final.add[,1]))))
		newdatacells <- as.integer(intersect(setdiff(fromto[,2],datacells),cells))
		datacells <- c(datacells,newdatacells)
	}
	colnames(fromto.final) <- c("from","to","buffer")
	return(fromto.final)
}

projection.correction.adjacency <- function(raster, adjacency) 
{
	correction <- matrix(NA, nrow=length(adjacency[,1]),ncol=3)
	correction[,1:2] <- cbind(raster.get.row.from.cell(raster,adjacency[,1]),raster.get.row.from.cell(raster,adjacency[,2]))
	lookup.table <- cbind(1/(cos((pi/180)*raster.get.y.from.row(raster,unique(correction[,1])))),cos((pi/180)*raster.get.y.from.row(raster,unique(correction[,1])+0.5)))
	rownames(lookup.table) <- as.character(unique(correction[,1]))
	lookup <- function(row,direction){lookup.table[as.character(row),direction]}
	correction[,3][correction[,1]==correction[,2]] <- lookup(correction[,1][correction[,1]==correction[,2]],1)
	correction[,3][correction[,1]!=correction[,2]] <- lookup(pmin(correction[,1][correction[,1]!=correction[,2]],correction[,2][correction[,1]!=correction[,2]]),2)
	adjacency.pc <- cbind(adjacency,correction[,3])
	return(adjacency.pc)
}

projection.correction.transition.matrix <- function(transition) 
{
	adjacency <- adjacency.from.transition(transition)
	correction <- matrix(NA, nrow=length(adjacency[,1]),ncol=3)
	correction[,1:2] <- cbind(raster.get.row.from.cell(transition,adjacency[,1]),raster.get.row.from.cell(transition,adjacency[,2]))
	lookup.table <- cbind(1/(cos((pi/180)*raster.get.y.from.row(transition,unique(correction[,1])))),cos((pi/180)*raster.get.y.from.row(transition,unique(correction[,1])+0.5)))
	rownames(lookup.table) <- as.character(unique(correction[,1]))
	lookup <- function(row,direction){lookup.table[as.character(row),direction]}
	correction[,3][correction[,1]==correction[,2]] <- lookup(correction[,1][correction[,1]==correction[,2]],1)
	correction[,3][correction[,1]!=correction[,2]] <- lookup(pmin(correction[,1][correction[,1]!=correction[,2]],correction[,2][correction[,1]!=correction[,2]]),2)
	i <- as.vector(adjacency[,1])
	j <- as.vector(adjacency[,2])
	x <- as.vector(correction[,3]) 
	Dim <- transition@ncells
	correction.matrix <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	correction.matrix <- (as(correction.matrix,"symmetricMatrix"))
	correction.matrix <- (as(correction.matrix,"dsCMatrix"))
	transition.corrected <- correction.matrix*as(transition, "dsCMatrix")
	transition <- dsCMatrix.to.transition(transition.corrected,transition)
	return(transition)
}

setGeneric("transition.create.from.raster", function(raster, transition.function, outer.meridian.connect) standardGeneric("transition.create.from.raster"))

setMethod("transition.create.from.raster", signature(raster = "raster"), def = function(raster, transition.function, outer.meridian.connect=FALSE)
{
	tm <- new("transition",nrows=raster@nrows,ncols=raster@ncols,xmin=raster@xmin,xmax=raster@xmax,ymin=raster@ymin,ymax=raster@ymax)
	adj <- adjacency(raster,outer.meridian.connect=outer.meridian.connect)
	transition.values <- apply(cbind(raster@data[adj[,1]],raster@data[adj[,2]]),1,transition.function)
	transition.dsC <- as(tm,"dsCMatrix")
	transition.dsC[adj] <- as.vector(transition.values)
	tm <- dsCMatrix.to.transition(transition.dsC,tm)
	return(tm)
}
)

setGeneric("transition.create.from.rasterstack.mahal", function(rasterstack, outer.meridian.connect) standardGeneric("transition.create.from.rasterstack.mahal"))

setMethod("transition.create.from.rasterstack.mahal", signature(rasterstack = "rasterstack"), 
	def = function(rasterstack, outer.meridian.connect)
	{
		adj <- adjacency(rasterstack@rasters[[1]],outer.meridian.connect=outer.meridian.connect) 
		x <- matrix(ncol=1,nrow=rasterstack@ncells)
		x[,1] <- as.integer(1:rasterstack@ncells)
		for (i in 1:rasterstack@nrasters) 
		{
			x <- cbind(x,rasterstack@rasters[[i]]@data[x[,1]])
			x <- na.omit(x)
		}
		adj <- subset(adj, (adj[,1] %in% x[,1] & adj[,2] %in% x[,2]))
		x.minus.y <- x[adj[,1],]-x[adj[,2],]
		cov.inv <- solve(cov(x))
		mahaldistance <- apply(x.minus.y,1,function(x){sqrt((x%*%cov.inv)%*%x)})
		mahaldistance <- mean(mahaldistance)/(mahaldistance+mean(mahaldistance))
		transition.dsC <- new("dsCMatrix", 
			p = as.integer(rep(0,rasterstack@ncells+1)),
			Dim = as.integer(c(rasterstack@ncells,rasterstack@ncells)),
			Dimnames = list(1:rasterstack@ncells,1:rasterstack@ncells)
			)
		transition.dsC[adj] <- mahaldistance
		transition <- new("transition",nrows=rasterstack@nrows,ncols=rasterstack@ncols,xmin=rasterstack@xmin,xmax=rasterstack@xmax,ymin=rasterstack@ymin,ymax=rasterstack@ymax)
		transition <- dsCMatrix.to.transition(transition.dsC,transition)
		return(transition)
	}
)

setGeneric("transition.stack.calc", function(ts,fun) standardGeneric("transition.stack.calc"))

setMethod("transition.stack.calc", signature(ts = "transition.stack"), def = function(ts,fun="prod"){
			if(fun=="prod")
			{
				nloops <- length(ts@rasters)
				tm1 <- as(ts@rasters[[1]], "dsCMatrix")
				result <- tm1
				for (i in 2:nloops)
				{
					result <- result*as(transition.stack[[i]], "dsCMatrix")
				}
				new.raster <- new("raster",
						projection = ts@projection,
						ncols = ts@ncols,
						nrows = ts@nrows,
						ncells = ts@ncells,
						xmin = ts@xmin,
						xmax = ts@xmax,
						ymin = ts@ymin,
						ymax = ts@ymax,
						xres = ts@xres,
						yres = ts@yres
				)
				return(new.raster)
			}
			else{stop("other methods not implemented yet")}
		}
)

raster.create.from.transition <- function(transition)
{
	if(transition@rowcolzero == TRUE)
		{raster <- new("raster",
			projection = transition@projection,
			ncols = transition@ncols,
			nrows = transition@nrows,
			ncells = transition@ncells,
			xmin = transition@xmin,
			xmax = transition@xmax,
			ymin = transition@ymin,
			ymax = transition@ymax,
			xres = transition@xres,
			yres = transition@yres,
			raster@data <- colSums(as("dsCMatrix",transition)))
		}
	if(transition@rowcolzero == TRUE)
		{raster <- new("raster",
			projection = transition@projection,
			ncols = transition@ncols,
			nrows = transition@nrows,
			ncells = transition@ncells,
			xmin = transition@xmin,
			xmax = transition@xmax,
			ymin = transition@ymin,
			ymax = transition@ymax,
			xres = transition@xres,
			yres = transition@yres,
			data = rep(NA,times=transition@ncells)
			)
		raster@data[as.integer(transition@Dimnames[[1]])] <- colSums(as("dsCMatrix",transition))
		}
	return(raster)
}

setGeneric("transition.solidify", function(ts,fun) standardGeneric("transition.solidify"))

setMethod("transition.solidify", signature(tm = "transition"), def = function(tm)
	{
		tm.dsC <- as(tm,"dsCMatrix")
		selection <- which(rowSums(tm.dsC)>0)
		tm.dsC <- tm.dsC[selection,selection]
		tm <- dsCMatrix.to.transition(tm.dsC,tm)
		tm@zerorowcol <- FALSE
		return(tm)
	}
)

setGeneric("transitionstack.create", function(object, ...) standardGeneric("transitionstack.create"))

setMethod("transitionstack.create", signature(object = "rasterstack"), def = function(object, ...)
		{
			transition.function <- (...)
			ts <- new("transitionstack",ntransitions=0,zerorowcol=object@zerorowcol,nrows=object@nrows,ncols=object@ncols,xmin=object@xmin,xmax=object@xmax,ymin=object@ymin,ymax=object@ymax)
			ts@transitions <- transition.create.from.raster(object@transitions[[1]])
			for (i in 2:object@nrasters)
			{
				ts@transitions <- c(ts@transitions,as(transition.create.from.raster(object@transitions[[i]]),"dsCMatrix"))
			}
			ts@ntransitions <- object@nrasters
			return(ts)
		}
)

setMethod("transitionstack.create", signature(object = "transition"), def = function(object, ...)
		{
			transition.list <- list(object, ...)
			for (i in 1:length(transition.list))
			{
				if (class(transition.list[[i]]) != "transition") {stop("not all objects are rasters")} else{}
				if (identical(FALSE,all.equal(transition.list[[i]]@zerorowcol,object@zerorowcol)) | identical(FALSE,all.equal(transition.list[[i]]@nrows,object@nrows)) | identical(FALSE,all.equal(transition.list[[i]]@ncols,object@ncols)) | identical(FALSE,all.equal(transition.list[[i]]@xmin,object@xmin)) | identical(FALSE,all.equal(transition.list[[i]]@xmax,object@xmax)) | identical(FALSE,all.equal(transition.list[[i]]@ymin,object@ymin)) | identical(FALSE,all.equal(transition.list[[i]]@ymax,object@ymax)))
				{stop("transition matrices do not have equal resolution and extent")} else{}	
			}
			for (i in 1:length(transition.list))
			{
				transition.list[[i]] <- as(transition.list[[i]],"dsCMatrix")
			}
			ts <- new("transitionstack",ntransitions=length(transition.list),zerorowcol=object@zerorowcol,nrows=object@nrows,ncols=object@ncols,ncells=object@ncells,xmin=object@xmin,xmax=object@xmax,ymin=object@ymin,ymax=object@ymax,transitions=transition.list)
		}
)

adjacency.from.transition <- function(transition)
{
	if (transition@zerorowcol == TRUE)
	{
		transition.dgT <- as(transition,"dgTMatrix")
		adjacency <- cbind(transition.dgT@i+1,transition.dgT@j+1)
	}
	if (transition@zerorowcol == FALSE)
	{
		transition.dgT <- as(transition,"dgTMatrix")
		adjacency <- cbind(transition@Dimnames[[1]][transition.dgT@i+1],transition@Dimnames[[2]][transition.dgT@j+1])		
	}
return(adjacency)
}

transition.connected.component <- function(transition, id.xy)
{
	adjacency <- adjacency.from.transition(transition)
	pointsofinterestin <- raster.get.cell.from.xy(transition, id.xy[,2:3])
	adj.graph <- graph.edgelist(cbind(as.character(adjacency[,1]),as.character(adjacency[,2])))
	pointsofinterest <- subset(pointsofinterestin, pointsofinterestin %in% V(adj.graph)$name)
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		warning(length(pointsofinterest), " out of ", length(pointsofinterestin), " locations were found in the adjacency matrix.","\n")
	}
	cl <- clusters(adj.graph)
	cluster.membership <- cbind(V(adj.graph)$name,cl$membership)
	grouping.pointsofinterest <- subset(cluster.membership, cluster.membership[,1] %in% pointsofinterest)
	setofcls <- unique(grouping.pointsofinterest[,2])
	select <- cbind(setofcls, tabulate(match(grouping.pointsofinterest[,2], setofcls)))
	select <- subset(select[,1],select[,2] == max(select[,2]))
	selected.pointsofinterest <- subset(grouping.pointsofinterest[,1],grouping.pointsofinterest[,2] == select)
	if (length(selected.pointsofinterest) < length(unique(pointsofinterest)))
	{
		warning(length(pointsofinterestin[pointsofinterestin %in% selected.pointsofinterest]), " out of ", length(pointsofinterestin)," locations were included in the selected connected component. ","\n")
	}
	selected.cells <- subset(cluster.membership[,1],cluster.membership[,2] == select)
	adjacency.cc <- subset(adjacency,(as.character(adjacency[,1]) %in% selected.cells & as.character(adjacency[,2]) %in% selected.cells))
	transition.dsC <- as(transition,"dsCMatrix")
	transition.dsC <- transition.dsC[adjacency.cc,adjacency.cc]
	transition <- dsCMatrix.to.transition(transition.dsC,transition)
	return(transition)
}

distance.from.level <- function(levels,fun)
{
	result <- matrix(NA,ncol=length(levels),nrow=length(levels))
	rownames(result) <- names(levels)
	colnames(result) <- names(levels)
	index <- cbind(rep(1:length(levels), each=length(levels)),rep(1:length(levels), times=length(levels)))
	result[index] <- apply(cbind(levels[index[,1]],levels[index[,2]]),1,fun)
	return(as.dist(result, diag=T))
}

Laplacian <- function(transition) 
{
	transition.dsC <- as(transition,"dsCMatrix")
	Laplacian.dsC <- Diagonal(x = colSums(transition.dsC)) - transition.dsC
	return(Laplacian.dsC)
}

raster.current.single.origin.single.destination <- function(transition,origin.xy,goal.xy)
{
	origin.cell <- raster.get.cell.from.xy(transition, origin.xy)
	goal.cell <- raster.get.cell.from.xy(transition, goal.xy)
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	A <- as(L,"lMatrix")
	A <- as(A,"dMatrix")
	n <- max(Lr@Dim)
	e <- matrix(0, ncol=1, nrow=n)
	rownames(e) <- rownames(transition)[1:n]
	e[as.character(origin.cell),] <- 1 
	e[as.character(goal.cell),] <- -1
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(x-sum(x/(n+1)),(sum(x)/(n+1)))
	V <- A * Lplusallrows
	d <- t(t(A) * diag(V))
	V <- - V + d	
	Current <- colSums(abs(V)*-L)/2
	names(Current) <- rownames(transition)
	return(Current)	
}

raster.potential.single.origin.single.destination <- function(transition,origin.xy,goal.xy)
{
	origin.cell <- raster.get.cell.from.xy(transition, origin.xy)
	goal.cell <- raster.get.cell.from.xy(transition, goal.xy)
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	e <- matrix(0, ncol=1, nrow=n)
	rownames(e) <- rownames(transition)[1:n]
	e[as.character(origin.cell),] <- 1 
	e[as.character(goal.cell),] <- -1
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
	Lplusallrows <- Lplusallrows - min(Lplusallrows)
	names(Lplusallrows) <- as.character(rownames(transition))
	return(Lplusallrows)	
}

raster.hitting.time.single.origin <- function(transition,origin.xy)
{
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	djj <- diag(L)
	ldj <- rep(0, times=(n+1)) #destination (d) to all cells (j)
	ldd <- rep(0, times=(n+1)) #destination to destination
	loj <- 0 #origin (o) to all cells
	lod <- rep(0, times=(n+1)) #origin to destination
	origin.cell <- raster.get.cell.from.xy(transition, origin.xy)
	originindex <- match(origin.cell, rownames(transition))
	count <- 0
	onepercent <- n/100
	if (length(originindex)<1 | length(originindex)>1) {cat("Ambiguous or non-existing origin.","\n"); stop}
	for (i in 1:n)
	{
		ei <- matrix((-1/(n+1)), ncol=1, nrow=n)
		ei[i] <- 1-(1/(n+1)) 
		xi <- solve(Lr,ei) 
		xi <- as.vector(xi)
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		ldj[i] <- sum(Lplusallrows*djj)
		ldd[i] <- Lplusallrows[i]*sum(djj)
		count <- count+1
		if(count>=onepercent) {cat("|"); count<-count-onepercent}
	}
	cat("|","\n")
	e <- matrix((-1/(n+1)), ncol=1, nrow=n)
	e[originindex,] <- 1-(1/(n+1)) 
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(x-sum(x/(n+1)),(sum(x)/(n+1)))
	loj <- sum(Lplusallrows*djj)
	lod <- Lplusallrows*sum(djj)
	AFPT <- (loj - lod - ldj + ldd)
	AFPT[n+1] <- AFPT[which(L[,n+1]<0)[1]]
	names(AFPT) <- as.character(rownames(transition))
	cat("|","\n")
	return(AFPT)
}

level.hitting.time.centrality.all.origins.xy <- function(transition,weights,id.xy)
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(transition, id.xy[,2:3]))
	L <- Laplacian(transition)
	L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(L@Dim)
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	indexvector <- match(pointsofinterest, rownames(transition))
	result <- vector(length=length(pointsofinterest))
	result.tc <- vector(length=length(pointsofinterest))
	for (i in 1:length(pointsofinterest))
	{
		ei <- as.matrix(diag(L))
		ei[indexvector[i],] <- -sum(diag(L))
		xi <- solve(L,ei) 
		xi <- as.vector(xi) 
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Voltagedifference <- Lplusallrows - Lplusallrows[indexvector[i]]
		result[i] <- sum(Voltagedifference) 
		result.tc[i] <- sum(Voltagedifference*weights) 
	}
	names(result) <- as.character(pointsofinterest)
	resultout <- as.vector(matrix(NA,ncol = length(pointsofinterestin[,1])))
	names(resultout) <- as.character(pointsofinterestin[,1])
	indexvector2 <- cbind(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest], pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest])
	resultout[as.character(indexvector2[,1])] <- result[as.character(indexvector2[,2])]
	names(result.tc) <- as.character(pointsofinterest)
	resultout.tc <- as.vector(matrix(NA,ncol = length(pointsofinterestin[,1])))
	names(resultout.tc) <- as.character(pointsofinterestin[,1])
	resultout.tc[as.character(indexvector2[,1])] <- result.tc[as.character(indexvector2[,2])]
	totalresult <- list(unw=resultout,w=resultout.tc)
	return(totalresult)
}

distance.joint.hitting.time.all.origins.xy <- function(transition, id.xy, weights)
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(transition, id.xy[,2:3]))
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	JC <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	rownames(JC) <- as.character(pointsofinterest)
	colnames(JC) <- as.character(pointsofinterest)
	JCt <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	rownames(JCt) <- as.character(pointsofinterest)
	colnames(JCt) <- as.character(pointsofinterest)
	onepercent <- ((length(pointsofinterest)^2)-length(pointsofinterest))/200
	indexvector <- match(pointsofinterest, rownames(transition))
	count <- 0
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	for (i in 1:(length(pointsofinterest)-1))
	{
		ei <- as.matrix(diag(Lr))
		ei[indexvector[i],] <- 1-(1/(n+1))
		xi <- solve(Lr,ei) 
		xi <- as.vector(xi) 
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Voltagedifferencei <- abs(Lplusallrows - Lplusallrows[indexvector[i]])
		ii <- i + 1
		for (j in ii:length(pointsofinterest))
		{
			ei <- as.matrix(diag(Lr))
			ei[indexvector[i],] <- 1-(1/(n+1))
			xi <- solve(Lr,ei) 
			xi <- as.vector(xi) 
			Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
			Voltagedifferencej <- abs(Lplusallrows - Lplusallrows[indexvector[j]])
			JC[j,i] <- (sum((pmin(Voltagedifferencei,Voltagedifferencej)))*2)/sum(Voltagedifferencei,Voltagedifferencej)
			JCt[j,i] <- (sum((pmin(Voltagedifferencei,Voltagedifferencej)*weights))*2)/sum((Voltagedifferencei+Voltagedifferencej)*weights)
			count <- count+1
			if(count>=onepercent) {cat("|"); count<-count-onepercent}
		}
	}
	cat("|","\n")
	diag(JC) <- 0
	diag(JCt) <- 0
	JCout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	JCtoJCoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	JCtoJCoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	JCtoJCoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	JCoutindex <- cbind(rep(JCtoJCoutIndex[,1], each=length(JCtoJCoutIndex[,1])),rep(JCtoJCoutIndex[,1], times=length(JCtoJCoutIndex[,1])))
	JCindex <- cbind(rep(JCtoJCoutIndex[,2], each=length(JCtoJCoutIndex[,2])),rep(JCtoJCoutIndex[,2], times=length(JCtoJCoutIndex[,2])))
	JCindex <- cbind(pmax(JCindex[,1],JCindex[,2]),pmin(JCindex[,1],JCindex[,2]))
	JCout[JCoutindex] <- JC[JCindex]
	JCtout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	JCtout[JCoutindex] <- JCt[JCindex] #as.dist etc.
	rownames(JCout) <- as.character(pointsofinterestin[,1])
	colnames(JCout) <- as.character(pointsofinterestin[,1])	
	rownames(JCtout) <- as.character(pointsofinterestin[,1])
	colnames(JCtout) <- as.character(pointsofinterestin[,1])	
	result <- list(unw=JCout,w=JCtout)	
	return(result)
}

distance.joint.trajectory.single.origin.xy <- function(transition, id.xy, origin.xy, weights) #transition is a sparse matrix. transition is a sparse matrix with as row/column names the cell numbers. Points of interest are locations (cellnumbers) for which we want to know mutual resistance distance. Procedure based on Fouss et al. (2007))
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(transition, id.xy[,2:3]))
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	origin <- as.character(raster.get.cell.from.xy(transition, origin.xy))
	if (origin %in% rownames(transition)) {} else {warning("The origin was not found in the transition matrix.")}
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	A <- as(L,"lMatrix")
	A <- as(A,"dMatrix")
	n <- max(Lr@Dim)
	CMS <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	CMSt <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	onepercent <- ((length(pointsofinterest)^2)-length(pointsofinterest))/200
	count <- 0
	index.xy <- match(pointsofinterest,rownames(transition))
	index.origin <- match(origin,rownames(transition))
	for (i in 1:(length(pointsofinterest)-1))
	{
		ei <- matrix(0, ncol=1, nrow=n)
		ei[index.xy[i],] <- -1
		ei[index.origin,] <- 1 
		xi <- solve(Lr,ei)
		xi <- as.vector(xi)
		Lplusallrowsi <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Vi <- A * Lplusallrowsi
		d <- t(t(A) * diag(Vi))
		Vi <- - Vi + d
		Currenti <- colSums(abs(Vi)*-L)/2
		ii <- i + 1
		for (j in ii:length(pointsofinterest))
		{
			ei <- matrix(0, ncol=1, nrow=n)
			ei[index.xy[j],] <- -1
			ei[index.origin,] <- 1 
			xi <- solve(Lr,ei) 
			xi <- as.vector(xi)
			Lplusallrowsj <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
			Vj <- A * Lplusallrowsj
			d <- diag(Vi)
			d <- t(t(A) * diag(Vj))
			Vj <- - Vj + d
			Currentj <- colSums(abs(Vj)*-L)/2
			CMS[j,i] <- sum((pmin(Currenti,Currentj)))/sum(Currenti,Currentj)
			CMSt[j,i] <- sum((pmin(Currenti,Currentj)*weights))/sum((Currenti+Currentj)*weights)
			count <- count+1
			if(count>=onepercent) {cat("|"); count<-count-onepercent}
		}
	}
	cat("|","\n")
	diag(CMS) <- 0
	diag(CMSt) <- 0
	CMSout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	CMStoCMSoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	CMStoCMSoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	CMStoCMSoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	CMSoutindex <- cbind(rep(CMStoCMSoutIndex[,1], each=length(CMStoCMSoutIndex[,1])),rep(CMStoCMSoutIndex[,1], times=length(CMStoCMSoutIndex[,1])))
	CMSindex <- cbind(rep(CMStoCMSoutIndex[,2], each=length(CMStoCMSoutIndex[,2])),rep(CMStoCMSoutIndex[,2], times=length(CMStoCMSoutIndex[,2])))
	CMSindex <- cbind(pmax(CMSindex[,1],CMSindex[,2]),pmin(CMSindex[,1],CMSindex[,2]))
	CMSout[CMSoutindex] <- CMS[CMSindex]
	CMStout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	CMStout[CMSoutindex] <- CMSt[CMSindex] #as.dist etc.
	rownames(CMSout) <- as.character(pointsofinterestin[,1])
	colnames(CMSout) <- as.character(pointsofinterestin[,1])	
	rownames(CMStout) <- as.character(pointsofinterestin[,1])
	colnames(CMStout) <- as.character(pointsofinterestin[,1])	
	result <- list(w=CMSout,unw=CMStout)	
	return(result)
}

distance.resistance.xy <- function(transition, id.xy) #transition is a sparse matrix. transition is a sparse matrix with as row/column names the cell numbers. id.xy is a matrix of three rows: ids, x and y coordinates. Procedure based on Fouss et al. (2007))
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(transition, id.xy[,2:3]))
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	L <- Laplacian(transition)
	L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(L@Dim)
	Lstarplus <- matrix(ncol=1,nrow=length(pointsofinterest))
	Lplus <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	index <- match(pointsofinterest,rownames(transition))
	for (i in 1:length(pointsofinterest))
	{
		ei <- matrix((-1/(n+1)), ncol=1, nrow=n)
		ei[index[i],] <- 1-(1/(n+1))
		xi <- solve(L,ei) 
		xi <- as.vector(xi)
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Lplus[,i] <- Lplusallrows[index]
	}
	RD <- (-2*Lplus + matrix(diag(Lplus),nrow=length(pointsofinterest),ncol=length(pointsofinterest)) + t(matrix(diag(Lplus),nrow=length(pointsofinterest),ncol=length(pointsofinterest)))) #* sum(transition)
	RDout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	RDtoRDoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	RDtoRDoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	RDtoRDoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	RDindex <- cbind(rep(RDtoRDoutIndex[,2], each=length(RDtoRDoutIndex[,2])),rep(RDtoRDoutIndex[,2], times=length(RDtoRDoutIndex[,2])))
	RDoutindex <- cbind(rep(RDtoRDoutIndex[,1], each=length(RDtoRDoutIndex[,1])),rep(RDtoRDoutIndex[,1], times=length(RDtoRDoutIndex[,1])))
	RDout[RDoutindex] <- RD[RDindex] #as.dist etc.
	rownames(RDout) <- as.character(pointsofinterestin[,1])
	colnames(RDout) <- as.character(pointsofinterestin[,1])	
	return(as.dist(RDout))
}


