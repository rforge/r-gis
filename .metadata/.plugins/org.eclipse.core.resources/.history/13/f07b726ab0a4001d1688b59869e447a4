# TODO: Add comment
# 
# Author: jvanetten
###############################################################################

require(raster)

a<-2
grf <- read.csv('Geo-referencing/WrongCountryFinal.csv')
colnames(grf)[5:10] <- c("Olat","Olon","BGID","BGlon","BGlat","BGunc")
grf.m <- as.matrix(grf[,5:10])

error.category <- function(xy) 
{	
	error.dist <- function(x){
		if(any(is.na(c(x[1], x[2], x[3], x[4])))){out <- NA}
		else{
			difference <- distance.greatcircle.xy(x[1], x[2], x[3], x[4]) 
			xy.exchange <- distance.greatcircle.xy(x[2], x[1], x[3], x[4]) 
			signch.lat <- distance.greatcircle.xy(x[1], -x[2], x[3], x[4]) 
			signch.lon <- distance.greatcircle.xy(-x[1], x[2], x[3], x[4]) 
			signch.latlon <- distance.greatcircle.xy(-x[2], -x[1], x[3], x[4])
		
			xy.signch.lat <- distance.greatcircle.xy(x[2], -x[1], x[3], x[4])
			xy.signch.lon <- distance.greatcircle.xy(-x[2], x[1], x[3], x[4])
			xy.signch.latlon <- distance.greatcircle.xy(-x[2], -x[1], x[3], x[4])
		
			wrong.lon <- distance.greatcircle.xy(0, x[2], a, x[4])
			wrong.lat <- distance.greatcircle.xy(x[1], 0, x[3], a)
		
			xy.wrong.lon <- distance.greatcircle.xy(x[2], 0, x[3], a)
			xy.wrong.lat <- distance.greatcircle.xy(0, x[1], a, x[4])
			signch.lat.wrong.lon <- distance.greatcircle.xy(0, -x[2], a, x[4])
			signch.lon.wrong.lat <- distance.greatcircle.xy(-x[1], 0, x[3], a)
		
			signch.lat.xy.wrong.lon <- distance.greatcircle.xy(-x[2], 0, x[3], a)
			signch.lon.xy.wrong.lat <- distance.greatcircle.xy(0, -x[1], a, x[4])
			out <- c(difference,xy.exchange,signch.lat,signch.lon,signch.latlon,xy.signch.lat,xy.signch.lon,xy.signch.latlon,wrong.lon,wrong.lat,xy.wrong.lon,xy.wrong.lat,signch.lat.wrong.lon,signch.lon.wrong.lat,signch.lat.xy.wrong.lon,signch.lon.xy.wrong.lat)
			return(out)
		}
	}
	dist <- matrix(ncol=16,nrow=length(xy[,1]))
	for(i in 1: length(xy[,1]))
	{
		dist[i,] <- error.dist(xy[i,])
	}
	errorNames <- c("difference","xy.exchange","signch.lat","signch.lon","signch.latlon","xy.signch.lat","xy.signch.lon","xy.signch.latlon","wrong.lon,wrong.lat","xy.wrong.lon,xy.wrong.lat","signch.lat.wrong.lon","signch.lon.wrong.lat","signch.lat.xy.wrong.lon","signch.lon.xy.wrong.lat")
	classify.function <- function(x)
	{
		if (any(is.na(x))){out <- NA}
		else {out <- errorNames[min(which(x==min(x)))]}
		return(out)
	}
	errorCategory <- apply(dist,1,classify.function)
	errorDistance <-
}

decision.function <- function(x){
	out <- "keep new"
	if (any(is.na(x))){out <- NA}
	else{
		if(x[2]<9 & x[2] != 1 & x[3]<(x[4]+25000) & x[5]>=1){out <- "keep corrected original, increase uncertainty"}
		if(x[2]<9 & x[2] != 1 & x[3]<x[4] & x[5]>=1){out <- "keep corrected original"}
		if(x[2] != 1 & x[2]<9 & x[3]>(x[4]+25000) & x[5]>=1){out <- "check"}
	}
	return(out)
}



grf.xy <- cbind(grf.m[,2],grf.m[,1],grf.m[,4:5])



for(i in 1: length(grf.xy[,1]))
{
	dist[i,] <- distance.function(grf.xy[i,])
}

error <- dist[,1]

min.dist <- apply(dist,1,min)

fraction <- function(x){fractions(x,max.denominator=x*10^ndigits(x))}

precision.index <- function(xy){
	ndigits <- function(coord){
		ndig <- pmax(0,nchar(abs(coord))-nchar(abs(trunc(coord,digits=0)))-1)
		return(ndig)}
	seconds <- function(coord){
		decimals <- 0:60 / 60
		diffnearestfraction <- sapply(coord, function(x) min(abs(x - decimals)))
		precision <- 10^-ndigits(coord) <= diffnearestfraction
		return(precision)}
	le <- length(xy[,1])
	xy <- cbind(1:length(xy[,1]),xy)
	xy <- na.omit(xy)
	index <- rep(1,times=length(xy[,1]))
	index[which(pmin(cbind(ndigits(xy[,2]),ndigits(xy[,3]))) > 0)] <- 2
	index[index == 2] <- index[index == 2] + as.numeric(seconds(xy[which(index == 2),2] * seconds(xy[which(index ==2),3])))
	xy <- na.omit(xy)
	xy.dec <- xy - trunc(xy,digits=0)
	precision <- seconds(as.vector(xy.dec))
	precision <- pmax(cbind(precision[1:length(xy[,1])],precision[(length(xy[,1])+1):length(precision)]))
	index.final <- rep(0, times=le)
	index.final[xy[,1]] <- index
	return(index.final)
}

#######################
frac.fun(c(0, 1, 0.8266667, .066666, 0.2666666), 75) 

for (i in 1:99){cat(i/100," ",fraction(i/100),"\n")}

min.digits <- pmin(ndigits(grf.m[,1]),ndigits(grf.m[,2]))

final <- cbind(dist[,1],error.category,min.dist,grf[,10],min.digits)


	
decision <- apply(final,1,decision.function)

final <- cbind(final,decision)
final.check <- subset(cbind(final,grf.m[,4:5]),final[,6] == "check")

correction.function <- function(x) 
{	
	out <- NA
	if(any(is.na(c(x[1], x[2], x[3]))))
	{}
	else{
		if(x[3]==2) {out <- c(x[2], x[1])}
		if(x[3]==3) {out <- c(x[1], -x[2])}
		if(x[3]==4) {out <- c(-x[1], x[2])}
		if(x[3]==5) {out <- c(-x[2], -x[1])}
		if(x[3]==6) {out <- c(x[2], -x[1])}
		if(x[3]==7) {out <- c(-x[2], x[1])}
		if(x[3]==8) {out <- c(-x[2], -x[1])}		
	}
	return(out)
}

suggested.correction.x <- apply(cbind(grf.xy[,1:2],error.category),1,function(x){correction.function(x)[1]})
suggested.correction.y <- apply(cbind(grf.xy[,1:2],error.category),1,function(x){correction.function(x)[2]})

final <- cbind(grf,error,error.category,min.dist,min.digits,decision,suggested.correction.x,suggested.correction.y)

final.check <- subset(final,final[,"decision"] == "check")

write.csv(na.omit(final[,c("accenumb_","BGlon","BGlat","suggested.correction.x","suggested.correction.y")]),'Geo-referencing/WrongCountryFromTo.csv',row.names=FALSE)

connect <- odbcConnectAccess("H:/Projects/PGR/Data/GPG2/SINGER/singerfeb2008")
query <- "SELECT instcode_, collsite, longituded, latituded FROM [acc];"
coordinates <- sqlQuery(connect, query)
odbcClose(connect)

detect.conversion.error <- function(xy){
	xy <- na.omit(xy)
	number.digits <- cbind(ndigits(xy[,1]),ndigits(xy[,2]))
	index <- which((pmin(number.digits[,1],number.digits[,2]) + (as.numeric(abs(number.digits[,1]-number.digits[,2]))==1))>=2)
	xy <- xy[index,]
	xy <- abs(xy)
	xy.dec <- xy - trunc(xy,digits=0)
	a <- length(subset(xy.dec,xy.dec[,1]<0.6 & xy.dec[,2]<0.6)[,1])
	b <- length(xy.dec[,1]) - a
	p.value <- chisq.test(c(a,b),p=c(0.36,0.64))$p.value
	return(list(p.value = p.value,estimated.number.wrongly.converted.coordinates = max(0,round(a - (a+b)*0.36)), total.evaluated.coordinates = a+b))}

detect.conversion.error <- function(xy,min.ndigits){
	xy <- na.omit(xy)
	number.digits <- cbind(ndigits(xy[,1]),ndigits(xy[,2]))
	index <- which((pmin(number.digits[,1],number.digits[,2]) + (as.numeric(abs(number.digits[,1]-number.digits[,2]))==1))>=min.ndigits)
	xy <- xy[index,]
	xy <- abs(xy)
	xy.dec <- xy - trunc(xy,digits=0)
	fr <- vector(length=10)
	for (i in 1:10){
		fr[i] <- (length(subset(xy.dec,xy.dec[,1]>((i-1)/10) & xy.dec[,2]<(i/10))[,1]) + length(subset(xy.dec,xy.dec[,1]>=((i-1)/10) & xy.dec[,2]<=(i/10))[,1]))/2
	}
	p.value <- chisq.test(fr,p=rep(0.1,times=10))$p.value
	return(list(p.value = p.value,frequencies = fr))}

hist.bias <- function(xy, ...){
	xy <- na.omit(xy)
	number.digits <- cbind(ndigits(xy[,1]),ndigits(xy[,2]))
	index <- which((pmin(number.digits[,1],number.digits[,2]) + (as.numeric(abs(number.digits[,1]-number.digits[,2]))==1))>=2)
	xy <- xy[index,]
	xy <- abs(xy)
	xy.dec <- xy - trunc(xy,digits=0)
	hist(as.vector(xy.dec),...)}

min.digits <- function(a,b) {min(c(a,b))+as.numeric(abs(a-b)==1)}

index <- 2
detect.conversion.error(subset(cbind(coordinates[,"longituded"],coordinates[,"latituded"]),coordinates[,"instcode_"] == index),4)

detect.conversion.error(cbind(coordinates[,"longituded"],coordinates[,"latituded"]),4)
a <- precision.index(cbind(coordinates[,"longituded"],coordinates[,"latituded"]))

hist(a[a>0.1&a<60],breaks=100,xlim=c(0,60),ylim=c(1,20000))

hist.bias(cbind(coordinates[,"longituded"],coordinates[,"latituded"]))
unique(coordinates[,"instcode_"])
2 17 20  5  7 15 18  4  1  3

hist(log(as.numeric(a)+1,base=60),breaks=64,xlim=c(0,4),main="Coordinate precision",xlab=expression("Precision index ("*log[60]~"of the denominator of the nearest fraction derived from the decimals)"),col=3,freq=FALSE)
lf <- function(x){log(fraction.bases(x),base=60)}

a <- precision.index(cbind(coordinates[,"longituded"],coordinates[,"latituded"]))

a <- nchar(coordinates[,"longituded"])