#FUNCTIONS

adjacency <- function(raster,outer.meridian.connect=FALSE) 
{
	cells <- c(1:raster@ncells)
	data <- cbind(cells, raster@data)
	datacells <- na.omit(data)[,1]
	left <- seq(raster@ncols+1,(raster@ncols*raster@nrows-2*raster@ncols+1),by=raster@ncols) 
	right <- seq(2*raster@ncols,raster@ncols*raster@nrows-raster@ncols,by=raster@ncols)
	upper <- 2:(raster@ncols-1)
	lower <- seq((raster@ncols*raster@nrows-raster@ncols+2),(raster@ncols*raster@nrows-1),by=1)
	upperleft <- 1
	upperright <- raster@ncols
	lowerleft <- raster@ncols*raster@nrows-raster@ncols+1
	lowerright <- raster@ncols*raster@nrows
	datacells.core <- setdiff(datacells,(c(left,right,upper,lower,upperleft,upperright,lowerleft,lowerright)))
	datacells.upper <- intersect(datacells,upper)
	datacells.lower <- intersect(datacells,lower)	
	datacells.left <- intersect(datacells,left)
	datacells.right <- intersect(datacells,right)
	datacell.upperleft <- intersect(datacells,upperleft)
	datacell.upperright <- intersect(datacells,upperright)
	datacell.lowerleft <- intersect(datacells,lowerleft)
	datacell.lowerright <- intersect(datacells,lowerright)
	from.core <- rep(datacells.core, times=4)
	to.core <- c(datacells.core+1,datacells.core-1,datacells.core+raster@ncols,datacells.core-raster@ncols)
	from.upper <- rep(datacells.upper, times=3)
	to.upper <- c(datacells.upper+1,datacells.upper-1,datacells.upper+raster@ncols)
	from.lower <- rep(datacells.lower, times=3)
	to.lower <- c(datacells.lower+1,datacells.lower-1,datacells.lower-raster@ncols)
	from.left <- rep(datacells.left, times=3)
	to.left <- c(datacells.left+1,datacells.left+raster@ncols,datacells.left-raster@ncols)
	from.right <- rep(datacells.right, times=3)
	to.right <- c(datacells.right-1,datacells.right+raster@ncols,datacells.right-raster@ncols)
	from.upperleft <- rep(datacell.upperleft, times=2)
	to.upperleft <- c(datacell.upperleft+1,datacell.upperleft+raster@ncols)
	from.upperright <- rep(datacell.upperright, times=2)
	to.upperright <- c(datacell.upperright-1,datacell.upperright+raster@ncols)
	from.lowerleft <- rep(datacell.lowerleft, times=2)
	to.lowerleft <- c(datacell.lowerleft+1,datacell.lowerleft-raster@ncols)
	from.lowerright <- rep(datacell.lowerright, times=2)
	to.lowerright <- c(datacell.lowerright-1,datacell.lowerright-raster@ncols)
	fromto <- rbind(cbind(from.core,to.core),cbind(from.upper,to.upper),cbind(from.lower,to.lower),cbind(from.left,to.left),cbind(from.right,to.right),cbind(from.upperleft,to.upperleft),cbind(from.upperright,to.upperright),cbind(from.lowerleft,to.lowerleft),cbind(from.lowerright,to.lowerright))
	if (outer.meridian.connect==TRUE) 
	{
		mer.from.left <- rbind(cbind(datacells.left,datacells.left+raster@ncols-1),cbind(datacell.upperleft,datacell.upperleft+raster@ncols-1),cbind(datacell.lowerleft,datacell.lowerleft+raster@ncols-1))
		mer.from.right <- rbind(cbind(datacells.right,datacells.right-raster@ncols+1),cbind(datacell.upperright,datacell.upperright-raster@ncols+1),cbind(datacell.lowerright,datacell.lowerright-raster@ncols+1))
		fromto <- rbind(fromto,mer.from.left,mer.from.right)
	}
	fromto <- subset(fromto,fromto[,2] %in% datacells)
	fromto <- cbind(fromto,rep(0,times=length(fromto[,1])))
	colnames(fromto) <- c("from","to","buffer")
	return(fromto)
}

projection.correction <- function(raster,adjacency) 
{
	raster.get.row.from.cell <- function (raster, cell) 
	{
		rownr <- as.integer(trunc(cell/(raster@ncols + 1))+1)
		return(rownr)
	}
	raster.get.y.from.row <- function(raster,rownr)
	{
		y <- raster@ymax - ((rownr - 0.5) * raster@yres)
		return(y)
	}
	correction <- matrix(NA, nrow=length(adjacency[,1]),ncol=3)
	correction[,1:2] <- cbind(raster.get.row.from.cell(raster,adjacency[,1]),raster.get.row.from.cell(raster,adjacency[,2]))
	lookup.table <- cbind(1/(cos((pi/180)*raster.get.y.from.row(raster,unique(correction[,1])))),cos((pi/180)*raster.get.y.from.row(raster,unique(correction[,1])+0.5)))
	rownames(lookup.table) <- as.character(unique(correction[,1]))
	lookup <- function(row,direction){lookup.table[as.character(row),direction]}
	correction[,3][correction[,1]==correction[,2]] <- lookup(correction[,1][correction[,1]==correction[,2]],1)
	correction[,3][correction[,1]!=correction[,2]] <- lookup(pmin(correction[,1][correction[,1]!=correction[,2]],correction[,2][correction[,1]!=correction[,2]]),2)
	i <- as.vector(adjacency[,1])
	j <- as.vector(adjacency[,2])
	x <- as.vector(correction[,3]) 
	Dim <- raster@ncells
	CM <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	CM <- (as(CM,"symmetricMatrix"))
	CM <- (as(CM,"dsCMatrix"))
	rownames(CM) <- as.character(1:raster@ncells)
	colnames(CM) <- as.character(1:raster@ncells)
	CM <- CM[which(rowSums(CM)>0),which(colSums(CM)>0)]
	return(CM)
}

transition.matrix <- function(raster,adjacency,fun,fun.buffer)
{
	index <- subset(adjacency[,1:2],adjacency[,3]==0)
	if (length(index[,1])>0)
	{
		x <- apply(cbind(raster@data[index[,1]],raster@data[index[,2]]),1,fun) 
		i <- index[,1]
		j <- index[,2]
	}
	index.buffer <- subset(adjacency[,1:2],adjacency[,3]>0)
	if (length(index.buffer[,1])>0)
	{
		buffer <- subset(adjacency[,3],adjacency[,3]>0)
		values.buffer <- sapply(buffer,fun.buffer) 
		x <- c(x,values.buffer)
		i <- c(i,index.buffer[,1])
		j <- c(j,index.buffer[,2])
	}
	Dim <- raster@ncells
	TM <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	TM <- (as(TM,"symmetricMatrix"))
	TM <- (as(TM,"dsCMatrix"))	
	rownames(TM) <- as.character(1:raster@ncells)
	colnames(TM) <- as.character(1:raster@ncells)
	TM <- TM[which(rowSums(TM)>0),which(colSums(TM)>0)]
	return(TM)
}

adjacency.buffer <- function(raster,limit,outer.meridian.connect=FALSE)
{
	fromto.final <- matrix(ncol=3,nrow=0)
	newdatacells <- NULL
	cells <- c(1:raster@ncells)
	data <- cbind(cells, raster@data)
	datacells <- na.omit(data)[,1]
	left <- seq(raster@ncols+1,(raster@ncols*raster@nrows-2*raster@ncols+1),by=raster@ncols) 
	right <- seq(2*raster@ncols,raster@ncols*raster@nrows-raster@ncols,by=raster@ncols)
	upper <- 2:(raster@ncols-1)
	lower <- seq((raster@ncols*raster@nrows-raster@ncols+2),(raster@ncols*raster@nrows-1),by=1)
	upperleft <- 1
	upperright <- raster@ncols
	lowerleft <- raster@ncols*raster@nrows-raster@ncols+1
	lowerright <- raster@ncols*raster@nrows
	for (i in 0:limit)
	{
		datacells.core <- setdiff(datacells,(c(left,right,upper,lower,upperleft,upperright,lowerleft,lowerright)))
		datacells.upper <- intersect(datacells,upper)
		datacells.lower <- intersect(datacells,lower)	
		datacells.left <- intersect(datacells,left)
		datacells.right <- intersect(datacells,right)
		datacell.upperleft <- intersect(datacells,upperleft)
		datacell.upperright <- intersect(datacells,upperright)
		datacell.lowerleft <- intersect(datacells,lowerleft)
		datacell.lowerright <- intersect(datacells,lowerright)
		from.core <- rep(datacells.core, times=4)
		to.core <- c(datacells.core+1,datacells.core-1,datacells.core+raster@ncols,datacells.core-raster@ncols)
		from.upper <- rep(datacells.upper, times=3)
		to.upper <- c(datacells.upper+1,datacells.upper-1,datacells.upper+raster@ncols)
		from.lower <- rep(datacells.lower, times=3)
		to.lower <- c(datacells.lower+1,datacells.lower-1,datacells.lower-raster@ncols)
		from.left <- rep(datacells.left, times=3)
		to.left <- c(datacells.left+1,datacells.left+raster@ncols,datacells.left-raster@ncols)
		from.right <- rep(datacells.right, times=3)
		to.right <- c(datacells.right-1,datacells.right+raster@ncols,datacells.right-raster@ncols)
		from.upperleft <- rep(datacell.upperleft, times=2)
		to.upperleft <- c(datacell.upperleft+1,datacell.upperleft+raster@ncols)
		from.upperright <- rep(datacell.upperright, times=2)
		to.upperright <- c(datacell.upperright-1,datacell.upperright+raster@ncols)
		from.lowerleft <- rep(datacell.lowerleft, times=2)
		to.lowerleft <- c(datacell.lowerleft+1,datacell.lowerleft-raster@ncols)
		from.lowerright <- rep(datacell.lowerright, times=2)
		to.lowerright <- c(datacell.lowerright-1,datacell.lowerright-raster@ncols)
		fromto.raw <- rbind(cbind(from.core,to.core),cbind(from.upper,to.upper),cbind(from.lower,to.lower),cbind(from.left,to.left),cbind(from.right,to.right),cbind(from.upperleft,to.upperleft),cbind(from.upperright,to.upperright),cbind(from.lowerleft,to.lowerleft),cbind(from.lowerright,to.lowerright))
		if (outer.meridian.connect==TRUE) 
		{
			mer.from.left <- rbind(cbind(datacells.left,datacells.left+raster@ncols-1),cbind(datacell.upperleft,datacell.upperleft+raster@ncols-1),cbind(datacell.lowerleft,datacell.lowerleft+raster@ncols-1))
			mer.from.right <- rbind(cbind(datacells.right,datacells.right-raster@ncols+1),cbind(datacell.upperright,datacell.upperright-raster@ncols+1),cbind(datacell.lowerright,datacell.lowerright-raster@ncols+1))
			fromto.raw <- rbind(fromto.raw,mer.from.left,mer.from.right)
		}
		final.add <- subset(fromto.raw,(fromto.raw[,1] %in% newdatacells | fromto.raw[,2] %in% newdatacells))
		final.add <- subset(final.add,(final.add[,1] %in% datacells & final.add[,2] %in% datacells))
		fromto.final <- rbind(fromto.final,cbind(final.add,rep(i,times=length(final.add[,1]))))
		newdatacells <- intersect(setdiff(fromto.raw[,2],datacells),cells)
		datacells <- c(datacells,newdatacells)
	}
	colnames(fromto.final) <- c("from","to","buffer")
	return(fromto.final)
}

adjacency.connected.component <- function(raster,adjacency,id.xy)
{	
	pointsofinterestin <- raster.get.cell.from.xy(raster, id.xy[,2:3])
	adj.graph <- graph.edgelist(cbind(as.character(adjacency[,1]),as.character(adjacency[,2])))
	pointsofinterest <- subset(pointsofinterestin, pointsofinterestin %in% V(adj.graph)$name)
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		warning(length(pointsofinterest), " out of ", length(pointsofinterestin), " locations were found in the adjacency matrix.","\n")
	}
	cl <- clusters(adj.graph)
	cluster.membership <- cbind(V(adj.graph)$name,cl$membership)
	grouping.pointsofinterest <- subset(cluster.membership, cluster.membership[,1] %in% pointsofinterest)
	setofcls <- unique(grouping.pointsofinterest[,2])
	select <- cbind(setofcls, tabulate(match(grouping.pointsofinterest[,2], setofcls)))
	select <- subset(select[,1],select[,2] == max(select[,2]))
	selected.pointsofinterest <- subset(grouping.pointsofinterest[,1],grouping.pointsofinterest[,2] == select)
	if (length(selected.pointsofinterest) < length(unique(pointsofinterest)))
	{
		warning(length(pointsofinterestin[pointsofinterestin %in% selected.pointsofinterest]), " out of ", length(pointsofinterestin)," locations were included in the selected connected component. ","\n")
	}
	selected.cells <- subset(cluster.membership[,1],cluster.membership[,2] == select)
	adjacency.cc <- subset(adjacency,(as.character(adjacency[,1]) %in% selected.cells & as.character(adjacency[,2]) %in% selected.cells))
	return(adjacency.cc)
}

distance.from.level <- function(levels,fun)
{
	result <- matrix(NA,ncol=length(levels),nrow=length(levels))
	rownames(result) <- names(levels)
	colnames(result) <- names(levels)
	index <- cbind(rep(1:length(levels), each=length(levels)),rep(1:length(levels), times=length(levels)))
	result[index] <- apply(cbind(levels[index[,1]],levels[index[,2]]),1,fun)
	return(as.dist(result, diag=T))
}

Laplacian <- function(A)
{
	Dim <- A@Dim[1]
	D <- as(Diagonal(A@Dim[1], x = as.numeric(colSums(A))), "sparseMatrix")
	L <- D-A
	return(as(L,"symmetricMatrix"))
}

raster.current.single.origin.single.destination <- function(raster,transition,origin.xy,goal.xy)
{
	origin.cell <- raster.get.cell.from.xy(raster, origin.xy)
	goal.cell <- raster.get.cell.from.xy(raster, goal.xy)
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	A <- as(L,"lMatrix")
	A <- as(A,"dMatrix")
	n <- max(Lr@Dim)
	e <- matrix(0, ncol=1, nrow=n)
	rownames(e) <- rownames(transition)[1:n]
	e[as.character(origin.cell),] <- 1 
	e[as.character(goal.cell),] <- -1
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(x-sum(x/(n+1)),(sum(x)/(n+1)))
	V <- A * Lplusallrows
	d <- t(t(A) * diag(V))
	V <- - V + d	
	Current <- colSums(abs(V)*-L)/2
	names(Current) <- rownames(transition)
	return(Current)	
}

raster.potential.single.origin.single.destination <- function(raster,transition,origin.xy,goal.xy)
{
	origin.cell <- raster.get.cell.from.xy(raster, origin.xy)
	goal.cell <- raster.get.cell.from.xy(raster, goal.xy)
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	e <- matrix(0, ncol=1, nrow=n)
	rownames(e) <- rownames(transition)[1:n]
	e[as.character(origin.cell),] <- 1 
	e[as.character(goal.cell),] <- -1
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
	Lplusallrows <- Lplusallrows - min(Lplusallrows)
	names(Lplusallrows) <- as.character(rownames(transition))
	return(Lplusallrows)	
}

raster.hitting.time.single.origin <- function(raster,transition,origin.xy)
{
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	djj <- diag(L)
	ldj <- rep(0, times=(n+1)) #destination (d) to all cells (j)
	ldd <- rep(0, times=(n+1)) #destination to destination
	loj <- 0 #origin (o) to all cells
	lod <- rep(0, times=(n+1)) #origin to destination
	origin.cell <- raster.get.cell.from.xy(raster, origin.xy)
	originindex <- match(origin.cell, rownames(transition))
	count <- 0
	onepercent <- n/100
	if (length(originindex)<1 | length(originindex)>1) {cat("Ambiguous or non-existing origin.","\n"); stop}
	for (i in 1:n)
	{
		ei <- matrix((-1/(n+1)), ncol=1, nrow=n)
		ei[i] <- 1-(1/(n+1)) 
		xi <- solve(Lr,ei) 
		xi <- as.vector(xi)
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		ldj[i] <- sum(Lplusallrows*djj)
		ldd[i] <- Lplusallrows[i]*sum(djj)
		count <- count+1
		if(count>=onepercent) {cat("|"); count<-count-onepercent}
	}
	cat("|","\n")
	e <- matrix((-1/(n+1)), ncol=1, nrow=n)
	e[originindex,] <- 1-(1/(n+1)) 
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(x-sum(x/(n+1)),(sum(x)/(n+1)))
	loj <- sum(Lplusallrows*djj)
	lod <- Lplusallrows*sum(djj)
	AFPT <- (loj - lod - ldj + ldd)
	AFPT[n+1] <- AFPT[which(L[,n+1]<0)[1]]
	names(AFPT) <- as.character(rownames(transition))
	cat("|","\n")
	return(AFPT)
}

level.hitting.time.centrality.all.origins.xy <- function(raster,transition,weights,id.xy)
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(raster, id.xy[,2:3]))
	L <- Laplacian(transition)
	L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(L@Dim)
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	indexvector <- match(pointsofinterest, rownames(transition))
	result <- vector(length=length(pointsofinterest))
	result.tc <- vector(length=length(pointsofinterest))
	for (i in 1:length(pointsofinterest))
	{
		ei <- as.matrix(diag(L))
		ei[indexvector[i],] <- -sum(diag(L))
		xi <- solve(L,ei) 
		xi <- as.vector(xi) 
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Voltagedifference <- Lplusallrows - Lplusallrows[indexvector[i]]
		result[i] <- sum(Voltagedifference) 
		result.tc[i] <- sum(Voltagedifference*weights) 
	}
	names(result) <- as.character(pointsofinterest)
	resultout <- as.vector(matrix(NA,ncol = length(pointsofinterestin[,1])))
	names(resultout) <- as.character(pointsofinterestin[,1])
	indexvector2 <- cbind(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest], pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest])
	resultout[as.character(indexvector2[,1])] <- result[as.character(indexvector2[,2])]
	names(result.tc) <- as.character(pointsofinterest)
	resultout.tc <- as.vector(matrix(NA,ncol = length(pointsofinterestin[,1])))
	names(resultout.tc) <- as.character(pointsofinterestin[,1])
	resultout.tc[as.character(indexvector2[,1])] <- result.tc[as.character(indexvector2[,2])]
	totalresult <- list(unw=resultout,w=resultout.tc)
	return(totalresult)
}

distance.joint.hitting.time.all.origins.xy <- function(raster, transition, id.xy, weights)
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(raster, id.xy[,2:3]))
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	JC <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	rownames(JC) <- as.character(pointsofinterest)
	colnames(JC) <- as.character(pointsofinterest)
	JCt <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	rownames(JCt) <- as.character(pointsofinterest)
	colnames(JCt) <- as.character(pointsofinterest)
	onepercent <- ((length(pointsofinterest)^2)-length(pointsofinterest))/200
	indexvector <- match(pointsofinterest, rownames(transition))
	count <- 0
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	for (i in 1:(length(pointsofinterest)-1))
	{
		ei <- as.matrix(diag(Lr))
		ei[indexvector[i],] <- 1-(1/(n+1))
		xi <- solve(Lr,ei) 
		xi <- as.vector(xi) 
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Voltagedifferencei <- abs(Lplusallrows - Lplusallrows[indexvector[i]])
		ii <- i + 1
		for (j in ii:length(pointsofinterest))
		{
			ei <- as.matrix(diag(Lr))
			ei[indexvector[i],] <- 1-(1/(n+1))
			xi <- solve(Lr,ei) 
			xi <- as.vector(xi) 
			Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
			Voltagedifferencej <- abs(Lplusallrows - Lplusallrows[indexvector[j]])
			JC[j,i] <- (sum((pmin(Voltagedifferencei,Voltagedifferencej)))*2)/sum(Voltagedifferencei,Voltagedifferencej)
			JCt[j,i] <- (sum((pmin(Voltagedifferencei,Voltagedifferencej)*weights))*2)/sum((Voltagedifferencei+Voltagedifferencej)*weights)
			count <- count+1
			if(count>=onepercent) {cat("|"); count<-count-onepercent}
		}
	}
	cat("|","\n")
	diag(JC) <- 0
	diag(JCt) <- 0
	JCout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	JCtoJCoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	JCtoJCoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	JCtoJCoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	JCoutindex <- cbind(rep(JCtoJCoutIndex[,1], each=length(JCtoJCoutIndex[,1])),rep(JCtoJCoutIndex[,1], times=length(JCtoJCoutIndex[,1])))
	JCindex <- cbind(rep(JCtoJCoutIndex[,2], each=length(JCtoJCoutIndex[,2])),rep(JCtoJCoutIndex[,2], times=length(JCtoJCoutIndex[,2])))
	JCindex <- cbind(pmax(JCindex[,1],JCindex[,2]),pmin(JCindex[,1],JCindex[,2]))
	JCout[JCoutindex] <- JC[JCindex]
	JCtout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	JCtout[JCoutindex] <- JCt[JCindex] #as.dist etc.
	rownames(JCout) <- as.character(pointsofinterestin[,1])
	colnames(JCout) <- as.character(pointsofinterestin[,1])	
	rownames(JCtout) <- as.character(pointsofinterestin[,1])
	colnames(JCtout) <- as.character(pointsofinterestin[,1])	
	result <- list(unw=JCout,w=JCtout)	
	return(result)
}

distance.joint.trajectory.single.origin.xy <- function(raster, transition, id.xy, origin.xy, weights) #transition is a sparse matrix. transition is a sparse matrix with as row/column names the cell numbers. Points of interest are locations (cellnumbers) for which we want to know mutual resistance distance. Procedure based on Fouss et al. (2007))
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(raster, id.xy[,2:3]))
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	origin <- as.character(raster.get.cell.from.xy(raster, origin.xy))
	if (origin %in% rownames(transition)) {} else {warning("The origin was not found in the transition matrix.")}
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	L <- Laplacian(transition)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	A <- as(L,"lMatrix")
	A <- as(A,"dMatrix")
	n <- max(Lr@Dim)
	CMS <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	CMSt <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	onepercent <- ((length(pointsofinterest)^2)-length(pointsofinterest))/200
	count <- 0
	index.xy <- match(pointsofinterest,rownames(transition))
	index.origin <- match(origin,rownames(transition))
	for (i in 1:(length(pointsofinterest)-1))
	{
		ei <- matrix(0, ncol=1, nrow=n)
		ei[index.xy[i],] <- -1
		ei[index.origin,] <- 1 
		xi <- solve(Lr,ei)
		xi <- as.vector(xi)
		Lplusallrowsi <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Vi <- A * Lplusallrowsi
		d <- t(t(A) * diag(Vi))
		Vi <- - Vi + d
		Currenti <- colSums(abs(Vi)*-L)/2
		ii <- i + 1
		for (j in ii:length(pointsofinterest))
		{
			ei <- matrix(0, ncol=1, nrow=n)
			ei[index.xy[j],] <- -1
			ei[index.origin,] <- 1 
			xi <- solve(Lr,ei) 
			xi <- as.vector(xi)
			Lplusallrowsj <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
			Vj <- A * Lplusallrowsj
			d <- diag(Vi)
			d <- t(t(A) * diag(Vj))
			Vj <- - Vj + d
			Currentj <- colSums(abs(Vj)*-L)/2
			CMS[j,i] <- sum((pmin(Currenti,Currentj)))/sum(Currenti,Currentj)
			CMSt[j,i] <- sum((pmin(Currenti,Currentj)*weights))/sum((Currenti+Currentj)*weights)
			count <- count+1
			if(count>=onepercent) {cat("|"); count<-count-onepercent}
		}
	}
	cat("|","\n")
	diag(CMS) <- 0
	diag(CMSt) <- 0
	CMSout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	CMStoCMSoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	CMStoCMSoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	CMStoCMSoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	CMSoutindex <- cbind(rep(CMStoCMSoutIndex[,1], each=length(CMStoCMSoutIndex[,1])),rep(CMStoCMSoutIndex[,1], times=length(CMStoCMSoutIndex[,1])))
	CMSindex <- cbind(rep(CMStoCMSoutIndex[,2], each=length(CMStoCMSoutIndex[,2])),rep(CMStoCMSoutIndex[,2], times=length(CMStoCMSoutIndex[,2])))
	CMSindex <- cbind(pmax(CMSindex[,1],CMSindex[,2]),pmin(CMSindex[,1],CMSindex[,2]))
	CMSout[CMSoutindex] <- CMS[CMSindex]
	CMStout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	CMStout[CMSoutindex] <- CMSt[CMSindex] #as.dist etc.
	rownames(CMSout) <- as.character(pointsofinterestin[,1])
	colnames(CMSout) <- as.character(pointsofinterestin[,1])	
	rownames(CMStout) <- as.character(pointsofinterestin[,1])
	colnames(CMStout) <- as.character(pointsofinterestin[,1])	
	result <- list(w=CMSout,unw=CMStout)	
	return(result)
}

distance.resistance.xy <- function(raster, transition, id.xy) #transition is a sparse matrix. transition is a sparse matrix with as row/column names the cell numbers. id.xy is a matrix of three rows: ids, x and y coordinates. Procedure based on Fouss et al. (2007))
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(raster, id.xy[,2:3]))
	pointsofinterest <- pointsofinterestin[,4][pointsofinterestin[,4] %in% rownames(transition)]
	if (length(pointsofinterest) < length(pointsofinterestin[,4])) {warning(length(pointsofinterest)," out of ",length(pointsofinterestin[,4])," locations were found in the adjacency matrix.","\n")}
	pointsofinterest <- unique(pointsofinterest)
	L <- Laplacian(transition)
	L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(L@Dim)
	Lstarplus <- matrix(ncol=1,nrow=length(pointsofinterest))
	Lplus <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	index <- match(pointsofinterest,rownames(transition))
	for (i in 1:length(pointsofinterest))
	{
		ei <- matrix((-1/(n+1)), ncol=1, nrow=n)
		ei[index[i],] <- 1-(1/(n+1))
		xi <- solve(L,ei) 
		xi <- as.vector(xi)
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Lplus[,i] <- Lplusallrows[index]
	}
	RD <- (-2*Lplus + matrix(diag(Lplus),nrow=length(pointsofinterest),ncol=length(pointsofinterest)) + t(matrix(diag(Lplus),nrow=length(pointsofinterest),ncol=length(pointsofinterest)))) #* sum(transition)
	RDout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	RDtoRDoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	RDtoRDoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	RDtoRDoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	RDindex <- cbind(rep(RDtoRDoutIndex[,2], each=length(RDtoRDoutIndex[,2])),rep(RDtoRDoutIndex[,2], times=length(RDtoRDoutIndex[,2])))
	RDoutindex <- cbind(rep(RDtoRDoutIndex[,1], each=length(RDtoRDoutIndex[,1])),rep(RDtoRDoutIndex[,1], times=length(RDtoRDoutIndex[,1])))
	RDout[RDoutindex] <- RD[RDindex] #as.dist etc.
	rownames(RDout) <- as.character(pointsofinterestin[,1])
	colnames(RDout) <- as.character(pointsofinterestin[,1])	
	return(as.dist(RDout))
}

add.transition <- function(...) 
{
	matrices.list <- list(...)
	l <- length(matrices.list)
	combined <- 0
	for (i in 1:l)
	{
		combined <- combined + (1/matrices.list[[i]]@x)
	}
	combined <- 1/combined
	result <- matrices.list[[1]]
	result@x <- combined
	return(result)
}

multiply.transition <- function(...) 
{
	matrices.list <- list(...)
	l <- length(matrices.list)
	combined <- 1
	for (i in 1:l)
	{
		combined <- combined * (matrices.list[[i]]@x)
	}
	result <- matrices.list[[1]]
	result@x <- combined
	return(result)
}

raster.change.subset <- function(raster,xmin,ymin,xmax,ymax)
{
	if (xmin<raster@xmin | ymin<raster@ymin | xmax>raster@xmax | ymax>raster@ymax) {stop("Value outside raster extent")}
	#TODO Round min/max values to nearest value corresponding to raster
	first.start.cell <- raster.get.cell.from.xy(raster, c(xmin,ymin))
	last.start.cell <- raster.get.cell.from.xy(raster, c(xmin,ymax))
	new.nrows <- as.integer(raster.get.row.from.y(raster,ymin)-raster.get.row.from.y(raster,ymax))
	new.ncols <- as.integer(raster.get.col.from.x(raster,xmax)-raster.get.col.from.x(raster,xmin)+1)
	start.cells <- seq(first.start.cell,last.start.cell,by=-raster@ncols)
	end.cells <- start.cells+new.nrows
	selected.cells <- unlist(mapply(seq, start.cells, end.cells))
	raster@xmin <- xmin
	raster@ymin <- ymin
	raster@xmax <- xmax
	raster@ymax <- ymax
	raster@data <- raster@data[selected.cells]
	raster@ncols <- new.ncols
	raster@nrows <- new.nrows
	raster@ncells <- new.ncols*new.nrows
	return(raster)
}

#PACKAGES -- not essential
require(RODBC)
require(maps) 
require(fields)

#PACKAGES -- required by functions
require(Matrix)
require(igraph)
require(Rgis)
require(cluster)

#MAIN PROGRAM

#Get grids
g <- raster.create.from.file('E:/documents2/Grid_data/alt30ma.grd')
g <- raster.read.all(g)

g.aez15 <- raster.create.from.file('E:/documents2/Grid_data/AEZ/plate15/plate15.bil')
g.aez15 <- raster.read.all(g.aez15)

# Load the coordinates, plot them on a world map, get cell numbers for the coordinates
connect = odbcConnectExcel("e:\\documents2\\GermplasmData\\DoebleyLab\\Plant_Samples_fin.xls");
query = "SELECT UniqueID, x, y FROM [test$] WHERE (((UniqueID) Is Not Null));"
geodataraw = sqlQuery(connect, query);
odbcClose(connect);
geodata <- subset(geodataraw, geodataraw[,1] %in% c(32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,230,231,232,233,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264))

#Plot the data on a map
plot(geodata[,2],geodata[,3])
world(ylim = c(-90, 90), xlim = NULL, add = TRUE, asp = 1, xlab = "", ylab = "", xaxt = "n", yaxt = "n", eps =	0.1, col=1,shift = FALSE, col.water="lightblue", col.land="lightgreen",	fill=T)
points(geodata[,2],geodata[,3], pch=20)

#Prepare transition matrix
adj.land <- adjacency(g)
adj.sea <- adjacency.buffer(g,10)
adj <- rbind(adj.land,adj.sea)
adj <- adjacency.connected.component(g,adj,geodata)
sea.value <- mean(transition.matrix(g,adj.land,function(x){1/(abs(x[1]-x[2])*0.03+1)},function(x){x})@x)
tm <- transition.matrix(g,adj,function(x){1/(abs(x[1]-x[2])*0.03+1)},function(x){sea.value})
corrm <- projection.correction(g,adj)
tm <- multiply.transition(tm,corrm)

#Calculate geographic variables
resistance.distance <- distance.resistance.xy(g, tm, geodata)

hitting.time <- raster.hitting.time.single.origin(g,tm,c(-100,18))
time.depth <- max(hitting.time)-hitting.time

time.depth.difference <- distance.from.level(time.depth[as.character(raster.get.cell.from.xy(g,geodata[,2:3]))],mean)

hitting.time.centrality <- level.hitting.time.centrality.all.origins.xy(g,tm,time.depth,geodata)
hitting.time.centrality.diff.unw <- distance.from.level(hitting.time.centrality$unw,function(x){abs(x[1]-x[2])})
hitting.time.centrality.diff.w <- distance.from.level(hitting.time.centrality$w,function(x){abs(x[1]-x[2])})

hitting.time.centrality.overlap <- distance.joint.hitting.time.all.origins.xy(g, tm, geodata, time.depth)
hitting.time.centrality.overlap.unw <- as.dist(hitting.time.centrality.overlap$unw)
hitting.time.centrality.overlap.w <- as.dist(hitting.time.centrality.overlap$w)

joint.trajectory <- distance.joint.trajectory.single.origin.xy(g, tm, geodata, c(-100,18), time.depth)
joint.trajectory.unw <- as.dist(joint.trajectory$w)
joint.trajectory.w <- as.dist(joint.trajectory$unw)