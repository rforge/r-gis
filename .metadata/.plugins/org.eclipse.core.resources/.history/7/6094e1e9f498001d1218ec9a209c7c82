setClass(
		Class="rasterchar",
		representation = representation(
				projection="character",
				ncols ="integer",
				nrows ="integer",
				ncells ="integer",
				xmin ="numeric",
				xmax ="numeric",
				ymin ="numeric",
				ymax ="numeric",		
				xres ="numeric",
				yres ="numeric"
		),
		validity = function(object)
		{
			cond1 <- object@ncols*object@nrows == object@ncells
			cond2 <- isTRUE(all.equal(object@xres,(xmax-xmin)/ncols))
			cond3 <- isTRUE(all.equal(object@yres,(ymax-xmin)/nrows))
			cond <- cond1 & cond2 & cond3
			return(cond)
		}
)

setClass(
		Class="transition",
		representation = representation(
			zerorowcol = "logical",
			uplo = "character",
			p = "integer",
			i = "integer",
			x = "numeric",
			Dim = "integer",
			Dimnames = "list"
		),
		contains = "rasterchar",
		validity = function(object){
			if(zerorowcol == TRUE)
			{
				cond1 <- all(object@ncells, object@Dim[1], object@Dim[2]) 
				cond2 <- isTRUE(all.equal(object@xres , (object@xmax-object@xmin)/object@ncols))
				cond3 <- isTRUE(all.equal(object@yres , (object@ymax-object@ymin)/object@nrows))
				cond4 <- length(p) == Dim[1]+1
				cond <- cond1 & cond2 & cond3 & cond4
			}
			if (zerorowcol == FALSE)
			{
				cond1 <- length(object@Dimnames[[1]]) == object@Dim[1]
				cond2 <- length(object@Dimnames[[2]]) == object@Dim[2]
				cond3 <- Dim[1] == Dim[2]
				cond4 <- max(as.numeric(Dimnames[[1]]),as.numeric(Dimnames[[2]])) <= Dim[1]
				cond5 <- length(Dimnames[[1]]==Dim[1]) & length(Dimnames[[1]]==Dim[1])
				cond <- cond1 & cond2 & cond3 & cond4 & cond5
			}
			return(cond)
		}
)

setClass(
		Class="transitionstack",
		representation = representation(
			ntransitions = "integer",
			transitions = "list",
			zerorowcol = "logical"
		),
		contains = "rasterchar",
		validity = function(object){
			lengthrasters <- length(object@rasters)
			dimensions1 <- unlist(lapply(object@rasters,function(x){dim(x)[1]}))
			dimensions2 <- unlist(lapply(object@rasters,function(x){dim(x)[2]}))
			dimensions.equal <- all(dimensions==dimensions[1]) & all(dimensions2==dimensions2[1]) #TODO USE all.equal... Solidified transition allowed?
			if(lengthraster == nrasters & dimensions.equal) {cond <- TRUE} 
			else{cond <- FALSE}
			return(cond)
		}
)

setClass(
		Class="transitionstack",
		representation = representation(
				ntransitions = "integer",
				transitions = "list",
				zerorowcol = "logical"
		),
		contains = "rasterchar",
		validity = function(object){
			lengthrasters <- length(object@rasters)
			
			if(object@zerorowcol == TRUE)
			{
				dims <- unlist(lapply(object@transitions,dim))
				dimensions.equal <- all(dims==as.integer(object@ncells))
			}
			else{}
			if(object@zerorowcol == FALSE)
			{
				#TODO implement validity check
			}
			else{}	
			if((lengthraster == nrasters) & dimensions.equal) {cond <- TRUE} else {cond <- FALSE}
			return(cond)
		}
)

setMethod ("show" , "transition", 
		function(object) {
			cat("class     :" , class(object), "\n")
			cat("nrows     :" , object@nrows, "\n")
			cat("ncols     :" , object@ncols, "\n")
			cat("ncells    :" , object@ncells, "\n")
			cat("projection:" , object@projection, "\n")
			cat("xmin      :" , object@xmin, "\n")
			cat("xmax      :" , object@xmax, "\n")
			cat("ymin      :" , object@ymin, "\n")
			cat("ymax      :" , object@ymax, "\n")
			cat("xres      :" , object@xres, "\n")
			cat("yres      :" , object@yres, "\n")
			cat ("\n")
		}
)

setMethod ("initialize", "transition",
		function(.Object,nrows,ncols,xmin,xmax,ymin,ymax)
		{
			ncells = as.integer(nrows*ncols)
			.Object@zerorowcol = TRUE
			.Object@nrows = as.integer(nrows)
			.Object@ncols = as.integer(ncols)
			.Object@ncells = as.integer(ncells)
			.Object@xmin = xmin
			.Object@xmax = xmax
			.Object@ymin = ymin
			.Object@ymax = ymax
			.Object@xres = (xmax-xmin)/ncols
			.Object@yres = (ymax-ymin)/nrows
			.Object@uplo = "U"
			.Object@p = as.integer(rep(0,ncells+1))
			.Object@i = integer(0)
			.Object@Dim = as.integer(c(ncells,ncells))
			.Object@Dimnames = list(1:ncells,1:ncells)
			return(.Object)
		}
)

setAs(
			from="transition",
			to="dsCMatrix",
			def=function(from){
				to <- new("dsCMatrix",
					uplo = from@uplo,
					p = from@p,
					i = from@i,
					x = from@x,
					Dim = from@Dim,
					Dimnames = from@Dimnames
					)
				return(to)
			},
)

setGeneric("dsCMatrix.to.transition", function(dsCMatrix,transition) standardGeneric("dsCMatrix.to.transition"))

setMethod ("dsCMatrix.to.transition", signature(dsCMatrix = "dsCMatrix", transition = "transition"),
	function(dsCMatrix,transition){
		transition@uplo = dsCMatrix@uplo
		transition@p = dsCMatrix@p
		transition@i = dsCMatrix@i
		transition@x = dsCMatrix@x
		transition@Dim = dsCMatrix@Dim
		transition@Dimnames = dsCMatrix@Dimnames
		return(transition)
	}
)

================================
		
		
		

setClass ("raster.new",
		representation (
				filename ="character",
				gdalhandle="list",
				rastername ="character",
				filetype ="character",
				datatype ="character",
				datasize ="integer",
				datasigned="logical",
				datanotation="character",
				byteorder ="character",
				valid ="logical",
				nbands ="integer",
				band = "integer",
				bandorder ="character",
				minvalue ="numeric",
				maxvalue ="numeric",
				nodatavalue ="numeric",
				data="array",
				datasource="character"
#		datablock="vector"
#		datamat ="matrix"
#		.data ="vector",
		),
		contains = "rasterchar",
		prototype (
				filename = "",
				gdalhandle= list(),
				rastername ="",
				filetype = "",
				datatype = "numeric",
				datasize = as.integer(4),
				datasigned= TRUE,
				datanotation="FLT4S",
				byteorder = .Platform$endian,
				valid = TRUE,
				projection= "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
				nbands = as.integer(1),
				band = as.integer(1),
				bandorder = "BSQ",
				ncols = as.integer(360),
				nrows = as.integer(180),
				ncells = as.integer(360 * 180),
				ncellvals = as.integer(360 * 180),
				xmin = -180,
				xmax = 180,
				ymin = -90,
				ymax = 90,
				xres =  1,
				yres =  1,
				minvalue = numeric (1),
				maxvalue = numeric (1),
				nodatavalue = -9999,
				data=array(NA,0),
				datasource=""
#		datablock=vector("integer", length=2)
		)
)