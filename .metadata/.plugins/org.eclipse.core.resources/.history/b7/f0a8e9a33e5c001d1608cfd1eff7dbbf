#PACKAGES

require(Matrix)
require(raster)
require(RODBC)
require(maps) 
require(fields)
require(RBGL)
require(graph)
require(igraph)
require(Rgis)

#FUNCTIONS

gsr <- function(Source, Search, Replace) #global search and replace (a normal replace doesn't work for dataframes) found on http://tolstoy.newcastle.edu.au/R/help/06/07/30503.html
{ 
	Changed <- as.character(Source) 
	for (i in 1:length(Search)) 
	{ 
		Changed <- replace(Changed, Changed == Search[i], Replace[i])   
	} 
	return(Changed) 
}

mutualgeodist <- function(geodata) #creates a matrix of mutual distances using greatcircledist
{
	md <-  matrix(0, nrow = NROW(geodata), ncol = NROW(geodata)) 
	n <- NROW(geodata)-1
	for (i in 1:n) 
	{
		x1 <- geodata[i,2]
		y1 <- geodata[i,3]
		ii <- i + 1
		for (j in ii:NROW(geodata)) 
		{
			x2 <- geodata[j,2]
			y2 <- geodata[j,3]
			md[j,i] <- greatcircledist(x1, y1, x2, y2) 
			#md[j,i] <- log1p(md[j,i], base = 10)}
		}
	}
	return(as.dist(md, diag = FALSE, upper = FALSE))
}

adjacencygrid <- function(gridcells,grid) 
{
	left <- seq(1,(grid@ncols*grid@nrows-grid@ncols+1),by=grid@ncols) 
	right <- seq(grid@ncols,grid@ncols*grid@nrows,by=grid@ncols)
	upper <- 1:grid@ncols
	lower <- seq((grid@ncols*grid@nrows-grid@ncols+1),grid@ncols*grid@nrows,by=1)
	border <- unique(c(left,right,upper,lower))
	gridcells <- setdiff(gridcells,border)
	from <- rep(gridcells, times=4)
	to <- c(gridcells+1,gridcells-1,gridcells+grid@ncols,gridcells-grid@ncols)
	one <- rep(1, times = length(gridcells) * 4)
	adj <- cbind(from,to,one)
	adj <- subset(adj, adj[,2] %in% gridcells)
	return(adj)
}

connectedbuffer <- function(adjacency,grid,startvalue,factor,limit) #TODO Integrate "connected buffer" and "adjacencygrid"
{
	u <- unique(adjacency[,1]) #adjacency is a dense matrix containing all adjacency combinations twice (symmetric)
	select <- rbind(u, tabulate(match(adjacency[,1], u)))
	select <- subset(select[1,],select[2,]<4)
	growthborder <- unique(adjacency[,1][adjacency[,1] %in% select]) #selects cells on the coast 
	behindgrowthborder <- unique(adjacency[,2][adjacency[,1] %in% select]) #select cells behind the coast, to avoid growing towards land later on
	remove(select); remove(u)
	buffer <- matrix(ncol=3)
	new <- matrix(nrow=4*length(growthborder),ncol=2)
	border <- unique(c(seq(1,(grid@ncols*grid@nrows-grid@ncols+1),by=grid@ncols),seq(grid@ncols,grid@ncols*grid@nrows,by=grid@ncols),1:grid@ncols,seq(grid@ncols*grid@nrows-grid@ncols+1,grid@ncols*grid@nrows,by=1)))
	for (i in 1:limit)
	{
		new[,1] <- rep(growthborder, times=4)
		new[,2] <- c((growthborder+1),(growthborder-1),(growthborder+grid@ncols),(growthborder-grid@ncols))
		new <- subset(new, new[,2] %in% setdiff(new[,2],c(growthborder,behindgrowthborder,border))) #Border (and land) nodes are excluded. This leaves the border free, but users may want to connect the borders. This can be achieved by inserting these connections separately.
		newcells <- unique(new[,2])
		mutual <- matrix(nrow=4*length(newcells),ncol=2)
		mutual[,1] <- rep(newcells, times=4)
		mutual[,2] <- c((newcells+1),(newcells-1),(newcells+grid@ncols),(newcells-grid@ncols))
		mutual <- subset(mutual, mutual[,2] %in% newcells)
		value <- rep(startvalue/factor^(i-1), times=length(mutual[,1])+length(new[,1]))
		buffer <- as.matrix(rbind(buffer,as.matrix(cbind(rbind(new,mutual),value))))
		behindgrowthborder <- growthborder
		growthborder <- newcells
		remove(new); remove(newcells)
		new <- matrix(nrow=length(growthborder)*4,ncol=2)
	}
	buffer <- na.omit(buffer)
	buffer <- rbind(buffer,cbind(buffer[,2],buffer[,1],buffer[,3]))
	buffer <- unique(buffer)
	return(buffer)
}

makesparse <- function(data,grid) # This function produces a sparse matrix with no empty rows or columns. Row and column NAMES refer to cell numbers, which can be retrieved like this: sparsematrix[as.character(cellnumber),]
{
	i <- as.numeric(data[,1])-1
	j <- as.numeric(data[,2])-1
	x <- data[,3]
	Dim <- grid@ncells
	A <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	B <- as(A, "dgCMatrix")
	C <- as(B, "symmetricMatrix")
	rownames(C) <- 1:Dim
	colnames(C) <- 1:Dim
	C <- C[which(rowSums(C)>0),which(colSums(C)>0)]
	return(C)
}

Laplacian <- function(A) #This function works around the limitation of matrices with Dim > 46340.
{
	i <- 0:(A@Dim[1]-1)
	j <- 0:(A@Dim[1]-1)
	x <- colSums(A)
	Dim <- A@Dim[1]
	D <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	L <- D-A
	return(as(L, "symmetricMatrix"))
}

getrelevantconnectedcomponent <- function(gra,pointsofinterestin)
{	
	pointsofinterest <- subset(pointsofinterestin, pointsofinterestin %in% V(gra)$name)
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		cat("Not all locations were found in the adjacency matrix.", length(pointsofinterestin)-length(pointsofinterest),"location(s) excluded.","\n")
	}
	cl <- clusters(gra)
	membership <- cbind(V(gra)$name,cl$membership)
	grouping <- subset(membership, membership[,1] %in% pointsofinterest)
	setofcls <- unique(grouping[,2])
	select <- cbind(setofcls, tabulate(match(grouping[,2], setofcls)))
	select <- subset(select[,1],select[,2] == max(select[,2]))
	grouping <- subset(grouping[,1],grouping[,2] == select)
	if (length(grouping) < length(pointsofinterest))
	{
		cat("Not all locations were included in the same connected component.", length(pointsofinterest)-length(grouping),"location(s) excluded.","\n")
	}
	result <- subset(membership[,1],membership[,2] == select)
	return(as.vector(result))
}

currentmap <- function(adjacency,goal,origin)
{
	L <- Laplacian(adjacency)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	A <- as(L,"lMatrix")
	A <- as(A,"dMatrix")
	n <- max(Lr@Dim)
	e <- matrix(0, ncol=1, nrow=n)
	rownames(e) <- rownames(adjacency)[1:n]
	e[as.character(goal),] <- -1
	e[as.character(origin),] <- 1 
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(x-sum(x/(n+1)),(sum(x)/(n+1)))
	V <- A * Lplusallrows
	d <- t(t(A) * diag(V))
	V <- - V + d	
	Current <- colSums(abs(V)*-L)/2
	names(Current) <- rownames(adjacency)
	return(Current)	
}

voltagemap <- function(adjacency,goal,origin)
{
	L <- Laplacian(adjacency)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	e <- matrix(0, ncol=1, nrow=n)
	rownames(e) <- rownames(adjacency)[1:n]
	e[as.character(goal),] <- -1
	e[as.character(origin),] <- 1 
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
	Lplusallrows <- Lplusallrows - min(Lplusallrows)
	names(Lplusallrows) <- as.character(rownames(adjacency))
	return(Lplusallrows)	
}

afptmap <- function(adjacency,origin)
{
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	L <- Laplacian(adjacency)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	djj <- diag(L)
	ldj <- rep(0, times=(n+1)) #destination (d) to all cells (j)
	ldd <- rep(0, times=(n+1)) #destination to destination
	loj <- 0 #origin (o) to all cells
	lod <- rep(0, times=(n+1)) #origin to destination
	originindex <- match(origin, rownames(adjacency))
	count <- 0
	if (length(originindex)<1 | length(originindex)>1) {cat("Ambiguous or non-existing origin.","\n"); stop}
	for (i in 1:n)
	{
		ei <- matrix((-1/(n+1)), ncol=1, nrow=n)
		ei[i] <- 1-(1/(n+1)) 
		xi <- solve(Lr,ei) 
		xi <- as.vector(xi)
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		ldj[i] <- sum(Lplusallrows*djj)
		ldd[i] <- Lplusallrows[i]*sum(djj)
		count <- count+1
		if (count/n>=0.01){count <- 0; cat("|")}
	}
	e <- matrix((-1/(n+1)), ncol=1, nrow=n)
	e[originindex,] <- 1-(1/(n+1)) 
	x <- solve(Lr,e) 
	x <- as.vector(x)
	Lplusallrows <- c(x-sum(x/(n+1)),(sum(x)/(n+1)))
	loj <- sum(Lplusallrows*djj)
	lod <- Lplusallrows*sum(djj)
	AFPT <- (loj - lod - ldj + ldd)
	AFPT[n+1] <- AFPT[which(L[,n+1]<0)[1]]
	names(AFPT) <- as.character(rownames(adjacency))
	cat("|","\n")
	return(AFPT)
}

afptcentrality <- function(adjacency,pointsofinterestin) #TODO Test this function
{
	L <- Laplacian(adjacency)
	L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(L@Dim)
	pointsofinterest <- intersect(as.character(pointsofinterestin),rownames(adjacency)[1:n])
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		cat("Not all points of interest were found in the (reduced) adjacency matrix.", length(pointsofinterestin)-length(pointsofinterest),"location(s) excluded.","\n")
	}
	indexvector <- match(pointsofinterest, rownames(adjacency))
	result <- vector(length=length(pointsofinterest))
	for (i in 1:length(pointsofinterest))
	{
		ei <- as.matrix(diag(L))
		ei[indexvector[i],] <- 1-(1/(n+1))
		xi <- solve(L,ei) 
		xi <- as.vector(xi) 
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Voltagedifference <- Lplusallrows - Lplusallrows[indexvector[i]]
		result[i] <- sum(Voltagedifference) 
	}
	names(result) <- as.character(pointsofinterest)
	resultout <- vector(length = length(pointsofinterestin))
	names(resultout) <- as.character(pointsofinterestin)
	resultout[names(result)] <- result
	return(resultout)
}

distance.jointRWreachability.all.cells.xy <- function(adjacency, pointsofinterestin, afpt)
{
	pointsofinterest <- intersect(as.character(pointsofinterestin),rownames(adjacency))
	if (length(pointsofinterest) < length (pointsofinterestin)) {cat("Not all points of interest were found in the adjacency matrix.", length(pointsofinterestin)-length(pointsofinterest),"location(s) excluded.","\n")}
	L <- Laplacian(adjacency)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(Lr@Dim)
	JC <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	rownames(JC) <- as.character(pointsofinterest)
	colnames(JC) <- as.character(pointsofinterest)
	JCt <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	rownames(JCt) <- as.character(pointsofinterest)
	colnames(JCt) <- as.character(pointsofinterest)
	no <- ((length(pointsofinterest)^2)-length(pointsofinterest))/2
	indexvector <- match(pointsofinterest, rownames(adjacency))
	count <- 0
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	for (i in 1:(length(pointsofinterest)-1))
	{
		ei <- as.matrix(diag(Lr))
		ei[indexvector[i],] <- 1-(1/(n+1))
		xi <- solve(Lr,ei) 
		xi <- as.vector(xi) 
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Voltagedifferencei <- abs(Lplusallrows - Lplusallrows[indexvector[i]])
		ii <- i + 1
		for (j in ii:length(pointsofinterest))
		{
			ei <- as.matrix(diag(Lr))
			ei[indexvector[i],] <- 1-(1/(n+1))
			xi <- solve(Lr,ei) 
			xi <- as.vector(xi) 
			Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
			Voltagedifferencej <- abs(Lplusallrows - Lplusallrows[indexvector[j]])
			JC[j,i] <- (sum((pmin(Voltagedifferencei,Voltagedifferencej)))*2)/sum(Voltagedifferencei,Voltagedifferencej)
			JCt[j,i] <- (sum((pmin(Voltagedifferencei,Voltagedifferencej)*afpt))*2)/sum((Voltagedifferencei+Voltagedifferencej)*afpt)
			count <- count+1
			if (count/no>=0.01){count <- 0; cat("|")}
		}
	}
	cat("|","\n")
	JCout <- matrix(nrow=length(pointsofinterestin),ncol=length(pointsofinterestin))
	rownames(JCout) <- as.character(pointsofinterestin)
	colnames(JCout) <- as.character(pointsofinterestin)
	JCout[as.character(pointsofinterest),as.character(pointsofinterest)] <- JC
	JCtout <- matrix(nrow=length(pointsofinterestin),ncol=length(pointsofinterestin))
	rownames(JCtout) <- as.character(pointsofinterestin)
	colnames(JCtout) <- as.character(pointsofinterestin)
	JCtout[as.character(pointsofinterest),as.character(pointsofinterest)] <- JCt
	result <- list(jointcentrality=JCout,jointcentrality.timecorrected=JCtout)	
	return(result)
	AFPTdata[as.numeric(names(AFPT))] <- AFPT
}

distance.jointflow.single.origin.xy <- function(raster, adjacency, id.xy, origin.xy, afpt) #Adjacency is a sparse matrix. Adjacency is a sparse matrix with as row/column names the cell numbers. Points of interest are locations (cellnumbers) for which we want to know mutual resistance distance. Procedure based on Fouss et al. (2007))
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(raster, id.xy[,2:3]))
	pointsofinterest <- intersect(unique(as.character(pointsofinterestin[,4])),rownames(adjacency))
	if (length(pointsofinterest) < length (pointsofinterestin)) {cat("Not all points of interest were found in the adjacency matrix.", length(pointsofinterestin)-length(pointsofinterest),"location(s) excluded.","\n")}
	origin <- raster.get.cell.from.xy(raster, origin.xy)
	if (origin %in% rownames(adjacency)) {} else {print("The origin was not found in the adjacency matrix.")}
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")
	L <- Laplacian(adjacency)
	Lr <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	A <- as(L,"lMatrix")
	A <- as(A,"dMatrix")
	n <- max(Lr@Dim)
	CMS <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	CMSt <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	no <- ((length(pointsofinterest)^2)-length(pointsofinterest))/2
	count <- 0
	index.xy <- match(pointsofinterest,rownames(adjacency))
	index.origin <- match(origin,rownames(adjacency))
	for (i in 1:(length(pointsofinterest)-1))
	{
		ei <- matrix(0, ncol=1, nrow=n)
		ei[index.xy[i],] <- -1
		ei[index.origin,] <- 1 
		xi <- solve(Lr,ei)
		xi <- as.vector(xi)
		Lplusallrowsi <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Vi <- A * Lplusallrowsi
		d <- t(t(A) * diag(Vi))
		Vi <- - Vi + d
		Currenti <- colSums(abs(Vi)*-L)/2
		ii <- i + 1
		for (j in ii:length(pointsofinterest))
		{
			ei <- matrix(0, ncol=1, nrow=n)
			ei[index.xy[j],] <- -1
			ei[index.origin,] <- 1 
			xi <- solve(Lr,ei) 
			xi <- as.vector(xi)
			Lplusallrowsj <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
			Vj <- A * Lplusallrowsj
			d <- diag(Vi)
			d <- t(t(A) * diag(Vj))
			Vj <- - Vj + d
			Currentj <- colSums(abs(Vj)*-L)/2
			CMS[j,i] <- sum((pmin(Currenti,Currentj)))/sum(Currenti,Currentj)
			CMSt[j,i] <- sum((pmin(Currenti,Currentj)*afpt))/sum((Currenti+Currentj)*afpt)
			count <- count+1
			if (count/no>=0.01){count <- 0; cat("|")}
		}
	}
	cat("|","\n")
	CMSout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	CMStoCMSoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	CMStoCMSoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	CMStoCMSoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	CMSoutindex <- cbind(rep(CMStoCMSoutIndex[,1], each=length(CMStoCMSoutIndex[,1])),rep(CMStoCMSoutIndex[,1], times=length(CMStoCMSoutIndex[,1])))
	CMSoutindex <- cbind(pmin(CMSoutindex[,1],CMSoutindex[,2]),pmax(CMSoutindex[,1],CMSoutindex[,2]))
	CMSindex <- cbind(rep(CMStoCMSoutIndex[,2], each=length(CMStoCMSoutIndex[,2])),rep(CMStoCMSoutIndex[,2], times=length(CMStoCMSoutIndex[,2])))
	CMSout[CMSoutindex] <- CMS[CMSindex]
	CMStout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	CMStout[CMSoutindex] <- CMSt[CMSindex] #as.dist etc.
	rownames(CMSout) <- as.character(pointsofinterestin[,1])
	colnames(CMSout) <- as.character(pointsofinterestin[,1])	
	rownames(CMStout) <- as.character(pointsofinterestin[,1])
	colnames(CMStout) <- as.character(pointsofinterestin[,1])	
	result <- list(jointflow=CMSout,jointflow.timecorrected=CMStout)	
	return(result)
}

distance.resistance.xy <- function(raster, adjacency, id.xy) #Adjacency is a sparse matrix. Adjacency is a sparse matrix with as row/column names the cell numbers. id.xy is a matrix of three rows: ids, x and y coordinates. Procedure based on Fouss et al. (2007))
{
	pointsofinterestin <- cbind(id.xy[,1:3],raster.get.cell.from.xy(raster, id.xy[,2:3]))
	pointsofinterest <- intersect(unique(as.character(pointsofinterestin[,4])),rownames(adjacency))
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		cat("Not all points of interest were found in the adjacency matrix.", length(pointsofinterestin)-length(pointsofinterest),"location(s) excluded.","\n")
	}
	L <- Laplacian(adjacency)
	L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
	n <- max(L@Dim)
	Lstarplus <- matrix(ncol=1,nrow=length(pointsofinterest))
	Lplus <- matrix(ncol=length(pointsofinterest),nrow=length(pointsofinterest))
	index <- match(pointsofinterest,rownames(adjacency))
	for (i in 1:length(pointsofinterest))
	{
		ei <- matrix((-1/(n+1)), ncol=1, nrow=n)
		ei[index[i],] <- 1-(1/(n+1))
		xi <- solve(L,ei) 
		xi <- as.vector(xi)
		Lplusallrows <- c(xi-sum(xi/(n+1)),(sum(xi)/(n+1)))
		Lplus[,i] <- Lplusallrows[index]
	}
	RD <- (-2*Lplus + matrix(diag(Lplus),nrow=length(pointsofinterest),ncol=length(pointsofinterest)) + t(matrix(diag(Lplus),nrow=length(pointsofinterest),ncol=length(pointsofinterest)))) #* sum(adjacency)
	RDout <- matrix(nrow=length(pointsofinterestin[,1]),ncol=length(pointsofinterestin[,1]))
	RDtoRDoutIndex <- matrix(nrow=length(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest]), ncol=2)
	RDtoRDoutIndex[,2] <- match(pointsofinterestin[,4][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterest)
	RDtoRDoutIndex[,1] <- match(pointsofinterestin[,1][pointsofinterestin[,4] %in% pointsofinterest],pointsofinterestin[,1])
	RDindex <- cbind(rep(RDtoRDoutIndex[,2], each=length(RDtoRDoutIndex[,2])),rep(RDtoRDoutIndex[,2], times=length(RDtoRDoutIndex[,2])))
	RDoutindex <- cbind(rep(RDtoRDoutIndex[,1], each=length(RDtoRDoutIndex[,1])),rep(RDtoRDoutIndex[,1], times=length(RDtoRDoutIndex[,1])))
	RDout[RDoutindex] <- RD[RDindex] #as.dist etc.
	rownames(RDout) <- as.character(pointsofinterestin[,1])
	colnames(RDout) <- as.character(pointsofinterestin[,1])	
	return(RDout)
}

#MAIN PROGRAM

#Get grid
g <- raster.create.from.file('E:/documents2/Grid_data/alt30ma.grd')
gdata.in <- raster.read.all(g)
#Dim <- length(gdata[,1])
#gridcells <- c(1:Dim)
gridcells <- c(1:g@ncells)
gdata <- cbind(gridcells, gdata.in@data)
gdata <- na.omit(gdata)

# Load the coordinates, plot them on a world map, get cell numbers for the coordinates

connect = odbcConnectExcel("e:\\documents2\\GermplasmData\\DoebleyLab\\Plant_Samples_fin.xls");
query = "SELECT UniqueID, x, y FROM [test$] WHERE (((UniqueID) Is Not Null));"
geodataraw = sqlQuery(connect, query);
odbcClose(connect);
geodata <- subset(geodataraw, geodataraw[,1] %in% c(32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,230,231,232,233,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264))

plot(geodata[,2],geodata[,3])
world(ylim = c(-90, 90), xlim = NULL, add = TRUE, asp = 1,
		xlab = "", ylab = "", xaxt = "n", yaxt = "n", eps =
				0.1, col=1,shift = FALSE, col.water="lightblue", col.land="lightgreen",
		fill=T)
points(geodata[,2],geodata[,3], pch=20)

# Calculate geographic distances between samples

#geodistance <- mutualgeodist(geodata)

adjgrid <- adjacencygrid(gdata[,1],g)

seagrid <- connectedbuffer(adjgrid,g,0.5,2,5)

totalgrid <- rbind(adjgrid,seagrid)

totalgrid[,1] <- as.character(totalgrid[,1])
totalgrid[,2] <- as.character(totalgrid[,2])

testgraph <- graph.edgelist(totalgrid[,1:2])

geodata <- cbind(geodata,raster.get.cell.from.xy(g, geodata[,2:3]))

cellnumbers <- unique(geodata[,4])

if(clusters(testgraph)$no>1)
{
	largecluster <- getrelevantconnectedcomponent(testgraph,cellnumbers)
	totalgrid <- makesparse(totalgrid,g)
	finalgrid <- totalgrid[as.character(largecluster),as.character(largecluster)]
} else {finalgrid <- makesparse(totalgrid,g)}

AFPT <- afptmap(finalgrid,103119)

distance.resistance <- distance.resistance.xy(g, finalgrid, geodata[,1:3])

distance.jointflow <- distance.jointflow.single.origin.xy(g, finalgrid, geodata[,1:3], c(-100,18), AFPT)

jcdistance <- jointcentrality(finalgrid,cellnumbers,AFPT)

jfdistance <- jointflow(finalgrid,cellnumbers,103119,AFPT)

AFPTdata <- NA

length(AFPTdata) <- 216000

AFPTdata[as.numeric(names(AFPT))] <- AFPT

firstAFPT <- raster.set.filename(g, "e:/documents2/Grid_data/FirstAFPTMap.asc")
write <- raster.write.ascii(firstAFPT, AFPTdata, overwrite=T)

#jointflow.dist <- matrix(nrow=attr(gendistance, "Size"),ncol=attr(gendistance,"Size"))
#rownames(jointflow.dist) <- attr(gendistance, "Labels")
#colnames(jointflow.dist) <- attr(gendistance, "Labels")
#jointflow.dist[as.character(geodata[,1]),as.character(geodata[,1])] <- jfdistance$jointflow[as.character(geodata[,4]),as.character(geodata[,4])]

#tc.jointflow.dist <- as.dist(jfdistance$jointflow.timecorrected)
#jointcentrality.dist <- as.dist(jcdistance$jointcentrality)
#tc.jointcentrality.dist <- as.dist(jcdistance$jointcentrality.timecorrected)

#Reformat distance matrix. This should be incorporated in the function.


#Current map and joint flow

#cm <- currentmap(finalgrid,cellnumbers[1],103119)
#vm <- voltagemap(finalgrid,cellnumbers[1],103119)
#rm <- resistancemap(finalgrid,103119)

#jfdistance <- jointflow(finalgrid,cellnumbers[1:10],103119)

#alt <- raster.create.from.file("e:/poverty/grids10m/alt")

#data <- raster.read.all(alt)
#logalt <- log(data)

#firstrmapasc <- raster.set.filename(g, "e:/documents/Grid_data/FirstResistanceMap.asc")
#write <- raster.write.ascii(firstrmapasc, rm)