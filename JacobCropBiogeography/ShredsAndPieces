add.transition <- function(...) 
{
	matrices.list <- list(...)
	l <- length(matrices.list)
	combined <- 0
	for (i in 1:l)
	{
		combined <- combined + (1/matrices.list[[i]]@x)
	}
	combined <- 1/combined
	result <- matrices.list[[1]]
	result@x <- combined
	return(result)
}

multiply.transition <- function(...) 
{
	matrices.list <- list(...)
	l <- length(matrices.list)
	combined <- 1
	for (i in 1:l)
	{
		combined <- combined * (matrices.list[[i]]@x)
	}
	result <- matrices.list[[1]]
	result@x <- combined
	return(result)
}

Laplacian <- function(A)
{
	Dim <- A@Dim[1]
	D <- as(Diagonal(A@Dim[1], x = as.numeric(colSums(A))), "sparseMatrix")
	L <- D-A
	return(as(L,"symmetricMatrix"))
}

		transition.dsC <- as(transition,"dsCMatrix")
		transition@p <- transition.dsC@p
		transition@i <- transition.dsC@i
		transition@x <- transition.dsC@x


transition.create.empty <- function(dim)
{
	transition.matrix <- new("dgTMatrix", Dim = as.integer(c(dim,dim)))
	transition.matrix <- (as(transition.matrix,"dgCMatrix"))	
	rownames(transition.matrix) <- as.character(1:dim)
	colnames(transition.matrix) <- as.character(1:dim)
	return(transition.matrix)
}

transition.dsC <- new("dsCMatrix", 
		p = as.integer(rep(0,6+1)),
		i = integer(0),
		Dim = as.integer(c(6,6)),
		Dimnames = list(1:6,1:6),
		uplo = "U"
		)

transition.dsC <- new("dsCMatrix", 
		p = as.integer(rep(0,6+1)),
		Dim = as.integer(c(6,6)),
		Dimnames = list(1:6,1:6)
		)

transition.create.from.raster <- function(raster, transition.function, outer.meridian.connect=FALSE) #help file should indicate that "sum" can be replaced by "prod" in the case the matrix already has data.
{
	transition <- transition.create.empty(raster@ncells)
	adj <- adjacency(raster,outer.meridian.connect=outer.meridian.connect)
	transition.values <- apply(cbind(raster@data[adj[,1]],raster@data[adj[,2]]),1,transition.function)
	transition[adj] <- as.vector(transition.values) 
	return(transition)
}

==================== Reproducible code

setClass("myClass", representation(extra="character"), contains = "dsCMatrix")

setMethod("initialize","myClass",function(.Object, nrows, ncols, extra) {
			.Object@extra = as.character(extra)
			.Object@uplo = "U"
			.Object@p = as.integer(rep(0,ncols+1))
			.Object@i = integer(0)
			.Object@Dim = as.integer(c(nrows,ncols))
			return(.Object)
		}
)

setMethod ("show" , "myClass", 
		function(object) {
			cat("extra: ",object@extra,"\n")
		}
)

setIs(
		class1="myClass",
		class2="dsCMatrix",
		coerce=function(from,to){
			to <- new("dsCMatrix",ncols=from@Dim[1],nrows=from@Dim[2])
			to@extra <- from@extra
			return(to) 
		},
		replace=function(from,value){
			return(from) 	
		}
)

setMethod("initialize","dsCMatrix",function(.Object, nrows, ncols) {
			.Object@uplo = "U"
			.Object@p = as.integer(rep(0,times=ncols+1))
			.Object@i = integer(0)
			.Object@Dim = as.integer(c(nrows,ncols))
			return(.Object)
		}
)

a <- new("myClass", nrows=3, ncols=3, extra="hello world")

a

validObject(a, test = TRUE, complete = TRUE)

a[1,1]

transition.create.empty <- function(dim)
{
	transition.matrix <- new("dgTMatrix", Dim = as.integer(c(dim,dim)))
	transition.matrix <- (as(transition.matrix,"dgCMatrix"))
	transition.matrix <- (as(transition.matrix,"symmetricMatrix"))
	rownames(transition.matrix) <- as.character(1:dim)
	colnames(transition.matrix) <- as.character(1:dim)
	return(transition.matrix)
}

#setMethod ("initialize", "transition",
	function(.Object,nrows,ncols,xmin,xmax,ymin,ymax)
{
	ncells <- as.integer(nrows*ncols)
	.Object@nrows <- as.integer(nrows)
	.Object@ncols <- as.integer(ncols)
	.Object@ncells <- as.integer(ncells)
	.Object@xmin <- xmin
	.Object@xmax <- xmax
	.Object@ymin <- ymin
	.Object@ymax <- ymax
	.Object@xres <- (xmax-xmin)/ncols
	.Object@yres <- (ymax-xmin)/nrows
	.Object@p <- as.integer(c(rep(0,times=ncells+1)))
	.Object@Dim <- as.integer(c(ncells,ncells))
	.Object@Dimnames <- list(as.character(1:ncells),as.character(1:ncells))
	.Object@uplo <- "U"
	return(.Object)
}
)

Laplacian <- function(A)
{
	Dim <- A@Dim[1]
	D <- as(Diagonal(A@Dim[1], x = as.numeric(colSums(A))), "sparseMatrix")
	L <- D-A
	return(L)
}

n <- 6
adj <- rbind(cbind(1:(n-1),2:n), cbind(2:n,1:(n-1))) # adjacency of a straight line.
tm <- new("dgTMatrix", Dim=as.integer(c(n,n)))
tm <- as(tm,"dgCMatrix")
tm[adj] <- 1
L <- Laplacian(tm)
L <- L[1:L@Dim[1]-1,1:L@Dim[2]-1]
Lplus <- solve(L)
RD <- (-2*Lplus + matrix(diag(Lplus),ncol=(n-1),nrow=(n-1)) + t(matrix(diag(Lplus),ncol=(n-1),nrow=(n-1))))

connected.component.from.adjacency <- function(raster,adjacency,id.xy)
{	
	pointsofinterestin <- raster.get.cell.from.xy(raster, id.xy[,2:3])
	adj.graph <- graph.edgelist(cbind(as.character(adjacency[,1]),as.character(adjacency[,2])))
	pointsofinterest <- subset(pointsofinterestin, pointsofinterestin %in% V(adj.graph)$name)
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		warning(length(pointsofinterest), " out of ", length(pointsofinterestin), " locations were found in the adjacency matrix.","\n")
	}
	cl <- clusters(adj.graph)
	cluster.membership <- cbind(V(adj.graph)$name,cl$membership)
	grouping.pointsofinterest <- subset(cluster.membership, cluster.membership[,1] %in% pointsofinterest)
	setofcls <- unique(grouping.pointsofinterest[,2])
	select <- cbind(setofcls, tabulate(match(grouping.pointsofinterest[,2], setofcls)))
	select <- subset(select[,1],select[,2] == max(select[,2]))
	selected.pointsofinterest <- subset(grouping.pointsofinterest[,1],grouping.pointsofinterest[,2] == select)
	if (length(selected.pointsofinterest) < length(unique(pointsofinterest)))
	{
		warning(length(pointsofinterestin[pointsofinterestin %in% selected.pointsofinterest]), " out of ", length(pointsofinterestin)," locations were included in the selected connected component. ","\n")
	}
	selected.cells <- subset(cluster.membership[,1],cluster.membership[,2] == select)
	adjacency.cc <- subset(adjacency,(as.character(adjacency[,1]) %in% selected.cells & as.character(adjacency[,2]) %in% selected.cells))
	return(adjacency.cc)
}

connected.component.from.transition.matrix <- function(raster,transition.matrix,id.xy)
{
	transition.matrix.dgT <- as(transition.matrix,"dgTMatrix")
	adjacency <- cbind(transition.matrix.dgT@i+1,transition.matrix.dgT@j+1)
	pointsofinterestin <- raster.get.cell.from.xy(raster, id.xy[,2:3])
	adj.graph <- graph.edgelist(cbind(as.character(adjacency[,1]),as.character(adjacency[,2])))
	pointsofinterest <- subset(pointsofinterestin, pointsofinterestin %in% V(adj.graph)$name)
	if (length(pointsofinterest) < length (pointsofinterestin)) 
	{
		warning(length(pointsofinterest), " out of ", length(pointsofinterestin), " locations were found in the adjacency matrix.","\n")
	}
	cl <- clusters(adj.graph)
	cluster.membership <- cbind(V(adj.graph)$name,cl$membership)
	grouping.pointsofinterest <- subset(cluster.membership, cluster.membership[,1] %in% pointsofinterest)
	setofcls <- unique(grouping.pointsofinterest[,2])
	select <- cbind(setofcls, tabulate(match(grouping.pointsofinterest[,2], setofcls)))
	select <- subset(select[,1],select[,2] == max(select[,2]))
	selected.pointsofinterest <- subset(grouping.pointsofinterest[,1],grouping.pointsofinterest[,2] == select)
	if (length(selected.pointsofinterest) < length(unique(pointsofinterest)))
	{
		warning(length(pointsofinterestin[pointsofinterestin %in% selected.pointsofinterest]), " out of ", length(pointsofinterestin)," locations were included in the selected connected component. ","\n")
	}
	selected.cells <- subset(cluster.membership[,1],cluster.membership[,2] == select)
	adjacency.cc <- subset(adjacency,(as.character(adjacency[,1]) %in% selected.cells & as.character(adjacency[,2]) %in% selected.cells))
	return(transition.matrix[adjacency.cc])
}

transition.matrix.create.from.adjacency <- function(adjacency)
{
	cells <- sort(unique(as.vector(adjacency[,1:2])))
	Dim <- length(cells)
	if (length(adjacency[1,])==3)
	{
		transition.matrix <- new("dgTMatrix", i=as.integer(adjacency[,1]-1), j=as.integer(adjacency[,2]-1), x=adjacency[,3], Dim = as.integer(c(Dim,Dim)))
	}
	if (length(adjacency[1,])==2)
	{
		transition.matrix <- new("dgTMatrix", Dim = as.integer(c(Dim,Dim)))
	}
	transition.matrix <- (as(transition.matrix,"dgCMatrix"))	
	rownames(transition.matrix) <- cells
	colnames(transition.matrix) <- cells
	return(transition.matrix)
}

transition.matrix.create.from.raster <- function(raster)
{
	Dim <- raster@ncells
	transition.matrix <- new("dgTMatrix", Dim = as.integer(c(Dim,Dim)))
	transition.matrix <- (as(transition.matrix,"symmetricMatrix"))
	transition.matrix <- (as(transition.matrix,"dsCMatrix"))	
	rownames(transition.matrix) <- as.character(1:raster@ncells)
	colnames(transition.matrix) <- as.character(1:raster@ncells)
	return(transition.matrix)
}

transition.matrix.create.from.adjacency <- function(adjacency)
{
	cells <- sort(unique(as.vector(adjacency[,1:2])))
	Dim <- length(cells)
	if (length(adjacency[1,])==3)
	{
		transition.matrix <- new("dgTMatrix", i=as.integer(adjacency[,1]-1), j=as.integer(adjacency[,2]-1), x=adjacency[,3], Dim = as.integer(c(Dim,Dim)))
	}
	if (length(adjacency[1,])==2)
	{
		transition.matrix <- new("dgTMatrix", Dim = as.integer(c(Dim,Dim)))
	}
	transition.matrix <- (as(transition.matrix,"symmetricMatrix"))
	transition.matrix <- (as(transition.matrix,"dsCMatrix"))	
	rownames(transition.matrix) <- cells
	colnames(transition.matrix) <- cells
	return(transition.matrix)
}

transition.matrix.create <- function(dim)
{
	transition.matrix <- new("dgTMatrix", Dim = as.integer(c(dim,dim)))
	transition.matrix <- (as(transition.matrix,"symmetricMatrix"))
	transition.matrix <- (as(transition.matrix,"dsCMatrix"))	
	rownames(transition.matrix) <- as.character(1:dim)
	colnames(transition.matrix) <- as.character(1:dim)
	return(transition.matrix)
}

raster.change.subset.old <- function(raster,xmin,ymin,xmax,ymax)
{
	xmin <- round(xmin/raster@xres)*raster@xres
	ymin <- round(ymin/raster@yres)*raster@yres
	xmax <- round(xmax/raster@xres)*raster@xres
	ymax <- round(ymax/raster@yres)*raster@yres
	if ((xmin>=raster@xmin | identical(TRUE, all.equal(xmin, raster@xmin)) ) & (ymin>=raster@ymin | identical(TRUE, all.equal(ymin, raster@ymin))) & (xmax<=raster@xmax | identical(TRUE, all.equal(xmax, raster@xmax))) & (ymax<=raster@ymax) | identical(TRUE, all.equal(ymax, raster@ymax))){}
	else{stop("Value outside raster extent")}
	new.nrows <- as.integer(raster.get.row.from.y(raster,ymin)-raster.get.row.from.y(raster,ymax))
	new.ncols <- as.integer(raster.get.col.from.x(raster,xmax)-raster.get.col.from.x(raster,xmin)+1)	
	
	first.start.cell <- as.integer(raster.get.cell.from.xy(raster, c(xmin,ymax)))
	last.start.cell <- as.integer(raster.get.cell.from.xy(raster, c(xmin,ymin+raster@yres)))
	start.cells <- seq(first.start.cell,last.start.cell,by=raster@ncols)
	end.cells <- start.cells+new.ncols-1
	selected.cells <- as.integer(unlist(mapply(seq, start.cells, end.cells)))
		
	raster@xmin <- xmin
	raster@ymin <- ymin
	raster@xmax <- xmax
	raster@ymax <- ymax
	raster@data <- raster@data[selected.cells]
	raster@ncols <- new.ncols
	raster@nrows <- new.nrows
	raster@ncells <- new.ncols*new.nrows
	raster@minvalue <- min(raster@data,na.rm=T)
	raster@maxvalue <- max(raster@data,na.rm=T)
	return(raster)
}

raster.change.aggregate.old.surrogate <- function(raster, func = mean, factor = 2, expand = TRUE, rm.NA = TRUE, INT = FALSE, filename=NA, overwrite=FALSE) 
{
	factor <- round(factor)
	if (factor < 2) {
		stop("factor should be > 1") }
	if (expand) {
		rsteps <- as.integer(ceiling(raster@nrows/factor))
		csteps <- as.integer(ceiling(raster@ncols/factor))
	} else 	{
		rsteps <- as.integer(floor(raster@nrows/factor))
		csteps <- as.integer(floor(raster@ncols/factor))
	}
	yexpansion <- (rsteps * factor - raster@nrows)  * raster@xres # formula modified
	xexpansion <- (csteps * factor - raster@ncols) * raster@yres # formula modified
	
	raster.aggregated <- raster
	if (!is.na(filename)) {raster.aggregated <- raster.set.filename(raster, filename)}
	else 
	{
		raster.aggregated@filename <- ""
	}
	raster.aggregated@xmax <- raster@xmax + xexpansion
	raster.aggregated@ymin <- raster@ymin - yexpansion
	raster.aggregated <- raster.set.rowcol(raster.aggregated, nrows=rsteps, ncols=csteps)  
	
	if (INT) { raster.aggregate <- raster.set.datatype(raster.aggregate, "integer") }
	else { raster.aggregate <- raster.set.datatype(raster.aggregate, "numeric") }
	
	#raster <- raster.determine.datasource(raster, makearray=T)
	
	if (length(raster@data) > 0) 
	{
		col.index <- rep(rep(1:csteps,each=factor)[1:raster@ncols],times=raster@nrows)
		row.index <- rep(1:rsteps,each=raster@ncols*factor)[1:raster@ncells]
		cell.index <- (csteps * (row.index - 1)) + col.index
		names(raster@data) <- ""
		if (rm.NA) {new.data <- as.array(tapply(raster@data,cell.index,function(x){func(na.omit(x))}))}
		else {new.data <- as.array(tapply(raster@data,cell.index,func))}	
		raster.aggregated@data <- new.data
		raster.aggregated@minvalue <- min(raster@data, na.rm=T)
		raster.aggregated@maxvalue <- max(raster@data, na.rm=T)
	}
	
	else if (length(raster@data) == 0) 
	{
		col.index <- rep(rep(1:csteps,each=factor)[1:raster@ncols],times=factor)
		new.data <- vector(length=rsteps*csteps)
		for (i in 1:rsteps) 
		{
			startrow <- 1 + (i - 1) * factor
			endrow <- min(raster@nrows, startrow + factor - 1)
			nrows <- endrow - startrow + 1
			data.selected.rows <- raster.read.rows(raster, startrow = startrow, nrows = nrows, band = raster@band)
			col.index <- col.index[1:(nrows*raster@ncols)]
			row.index <- rep(startrow:endrow,each=raster@ncols*nrows)
			cell.index <- (as.integer(csteps * (row.index - 1)) + col.index)
			if (rm.NA) { x <- na.omit(x) }  
			new.data[cell.index] <- tapply(raster@data, cell.index, function(x){fun(x)})
			raster.aggregated <- raster.write.binary.row(raster.aggregated, i, overwrite=overwrite)
		}
	}
	return(raster.aggregated)
}

raster.change.aggregate <- function (raster, func = mean, factor = 2, expand = TRUE, filename="Not specified.", rm.NA = TRUE, INT = FALSE) 
{
	factor <- round(factor)
	if (factor < 2) 
	{
		stop("factor should be >= 2")
	}
	if (expand) 
	{
		rsteps <- ceiling(raster@nrows/factor)
		csteps <- ceiling(raster@ncols/factor)
	}
	else 
	{
		rsteps <- floor(raster@nrows/factor)
		csteps <- floor(raster@ncols/factor)
	}
	yexpansion <- (rsteps * factor - raster@nrows)  * raster@xres # formula modified
	xexpansion <- (csteps * factor - raster@ncols) * raster@yres # formula modified
	if (length(raster@data)==0) #This part of the function not yet tested.
	{
		col.index <- rep(rep(1:csteps,each=factor)[1:raster@ncols],times=factor)
		new.data <- vector(length=rsteps*csteps)
		for (i in 1:rsteps) 
		{
			startrow <- 1 + (i - 1) * factor
			endrow <- min(raster@nrows, startrow + factor - 1)
			nrows <- endrow - startrow + 1
			data.selected.rows <- raster.read.rows(raster, startrow = startrow, nrows = nrows, band = raster@band)
			col.index <- col.index[1:(nrows*raster@ncols)]
			row.index <- rep(startrow:endrow,each=raster@ncols*nrows)
			cell.index <- (as.integer(csteps * (row.index - 1)) + col.index)
			if (rm.NA){new.data[cell.index] <- tapply(raster@data,cell.index,function(x){func(na.omit(x))})}
			else {new.data[cell.index] <- tapply(raster@data,cell.index,func)}
		}
	new.data <- as.array(new.data)
	}
	if (length(raster@data)>0) 
	{
		col.index <- rep(rep(1:csteps,each=factor)[1:raster@ncols],times=raster@nrows)
		row.index <- rep(1:rsteps,each=raster@ncols*factor)[1:raster@ncells]
		cell.index <- as.integer((csteps * (row.index - 1)) + col.index)
		if (rm.NA) {new.data <- as.array(tapply(raster@data,cell.index,function(x){func(na.omit(x))}))}
		else {new.data <- as.array(tapply(raster@data,cell.index,func))}
	}
	raster.aggregated <- raster
	raster.aggregated@data <- new.data
	raster.aggregated@ncols <- as.integer(csteps)
	raster.aggregated@nrows <- as.integer(rsteps)
	raster.aggregated@ncells <- as.integer(raster.aggregated@ncols * raster.aggregated@nrows)
	raster.aggregated@xmax <- raster@xmax + xexpansion
	raster.aggregated@ymin <- raster@ymin - yexpansion
	raster.aggregated@xres <- raster@xres * factor
	raster.aggregated@yres <- raster@yres * factor
	raster.aggregated@minvalue <- min(new.data,na.rm=T)
	raster.aggregated@maxvalue <- max(new.data,na.rm=T)
	raster.aggregated@filename <- ""
	return(raster.aggregated)
}

adj.land <- adjacency(g)
adj.sea <- adjacency.buffer(g,10)
adj <- rbind(adj.land,adj.sea)
adj <- connected.component.from.adjacency(g,adj,geodata)
sea.value <- mean(transition.matrix.create.from.adjacency(g,adj.land,function(x){1/(abs(x[1]-x[2])*0.03+1)},function(x){x})@x)
tm <- transition.matrix(g,adj,function(x){1/(abs(x[1]-x[2])*0.03+1)},function(x){sea.value})
corrm <- projection.correction(g,adj)
tm <- multiply.transition(tm,corrm)

transition.matrix <- function(raster,adjacency,fun,fun.buffer)
{
	index <- subset(adjacency[,1:2],adjacency[,3]==0)
	if (length(index[,1])>0)
	{
		x <- apply(cbind(raster@data[index[,1]],raster@data[index[,2]]),1,fun) 
		i <- index[,1]
		j <- index[,2]
	}
	index.buffer <- subset(adjacency[,1:2],adjacency[,3]>0)
	if (length(index.buffer[,1])>0)
	{
		buffer <- subset(adjacency[,3],adjacency[,3]>0)
		values.buffer <- sapply(buffer,fun.buffer) 
		x <- c(x,values.buffer)
		i <- c(i,index.buffer[,1])
		j <- c(j,index.buffer[,2])
	}
	Dim <- raster@ncells
	TM <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	TM <- (as(TM,"symmetricMatrix"))
	TM <- (as(TM,"dsCMatrix"))	
	rownames(TM) <- as.character(1:raster@ncells)
	colnames(TM) <- as.character(1:raster@ncells)
	TM <- TM[which(rowSums(TM)>0),which(colSums(TM)>0)]
	return(TM)
}

cor.dist <- function(gendistance, geodistance, lags)
{
	lags <- c(0,lags)
	geodistance <- as.matrix(geodistance)
	gendistance <- as.matrix(gendistance)
	lags.matrix <- matrix(ncol=length(gendistance[,1]), nrow=length(gendistance[,1]))
	diag(gendistance) <- NA
	geodistance[is.na(geodistance)] <-  lags[length(lags)]+1
	corr <- matrix(nrow=length(gendistance[,1]),ncol=length(gendistance[,1]))
	for (l in 1:(length(lags)-1))
	{	
		gendistance.sub <- gendistance
		gendistance.sub[geodistance<lags[l] | geodistance>lags[l+1]] <- NA
		lags.matrix[!is.na(gendistance.sub)] <- l
		for (i in 1:length(gendistance.sub[,1]))
			{
				di <- gendistance.sub[,i]
				for (j in 1:length(gendistance.sub[,1]))
				{
					dj <- gendistance[,j]
					dij <- na.omit(cbind(di,dj))
					if(length(dij)>2) {corr[i,j] <- cor(dij[,1],dij[,2])}
					else {corr[i,j] <- NA}
				}
			}
	}
	return(list(corr,lags.matrix,lags))
}

min.mean.proportion.per.lag <- function(gendistance,geodistance,lags,nsimulations)
{
	gendistance <- as.matrix(gendistance)
	diag(gendistance) <- max(gendistance+1)
	proportions <- vector(length=length(lags))
	lags <- c(0,lags,max(geodistance))
	for (i in 1:length(lags)+1)
	{
		means.proportions <- vector(length=length(gendistance[,1]))
		n.inside.radius <- vector(length=length(gendistance[,1]))
		for (n in 1:length(gendistance[,1]))
		{
			gendistance.selection <- subset(gendistance[,n],(geodistance.selection>lag[i] & geodistance.selection<lag[i+1])) 
			if (length(gendistance.selection)>2)
			{
				x <- 1:(length(gendistance.selection[,1]))*mean(gendistance.selection)
				mda <- min.distance.accumulation(gendistance.selection,nsimulations)
				means.proportions[n] <- coef(nls(mda ~ x^pow, start = c(pow=0.9), alg = 'plinear', trace = TRUE))[1]
				n.inside.radius[n] <- length(gendistance.selection)
			}
		else {proportions[n]<- -99}
		}	
	}
	return(proportions)
}

#Crap
#inv.d.resistance <- max(ifelse(is.na(d.resistance),-Inf,d.resistance)) - d.resistance

#AFPTdata <- NA
#length(AFPTdata) <- 216000
#AFPTdata[as.numeric(names(AFPT))] <- AFPT
#firstAFPT <- raster.set.filename(g, "e:/documents2/Grid_data/FirstAFPTMap.asc")
#write <- raster.write.ascii(firstAFPT, AFPTdata, overwrite=T)

#firstrmapasc <- raster.set.filename(g, "e:/documents/Grid_data/FirstResistanceMap.asc")
#write <- raster.write.ascii(firstrmapasc, rm)

genetic.distance <- function(data)
{
	data <- na.omit(data)
	data <- subset(data,data[,3]!=0)
	accession.index <- unique(data[,1])
	marker.fragment <- paste(data[,2],data[,3],sep="-")
	marker.fragment.index <- unique(marker.fragment)
	i <- match(data[,1],accession.index)-1
	j <- match(marker.fragment,marker.fragment.index)-1
	x <- rep(1,times=length(data[,1]))
	Dim1 <- length(accession.index)
	Dim2 <- length(marker.fragment.index)
	data.matrix <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim1,Dim2)))
	data.matrix <- as(data.matrix,"dgCMatrix")
	marker.index <- unlist(strsplit(marker.fragment.index,"-"))[seq(from=1,to=length(marker.fragment.index)*2,by=2)]
	distance.matrix <- matrix(0,ncol=length(accession.index),nrow=length(accession.index))
	sum.total <- t(apply(data.matrix,1,function(x){tapply(x,marker.index,sum)}))
	data.matrix.logical <- Matrix(as.integer(as.logical(data.matrix)),ncol=ncol(data.matrix))
	onepercent <- length(accession.index)/100
	count <- 0
	cat("Progress Bar", "\n")
	cat("---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|","\n")	
	for (i in 1:length(accession.index))
	{
		from <- t(t(data.matrix.logical) * data.matrix[i,])
		to <- t(t(data.matrix)*as.numeric(as.logical(data.matrix[i,])))
		sum.from <- t(apply(from,1,function(x){tapply(x,marker.index,sum)}))
		sum.to <- t(apply(to,1,function(x){tapply(x,marker.index,sum)}))
		distance.matrix[,i] <- apply(pmin(sum.from/(sum.total+0.0000001),sum.to/(sum.total+0.0000001)),1,mean)
		count <- count+1
		if(count>=onepercent) {cat("|"); count<-0}
	}
	cat("|","\n")
	distance.matrix <- t(distance.matrix * sqrt(1/diag(distance.matrix))) * sqrt(1/diag(distance.matrix))
	rownames(distance.matrix) <- as.character(accession.index)
	colnames(distance.matrix) <- as.character(accession.index)
	return(distance.matrix)
}

genetic.distance <- function(datain, method="shared.proportion") #Generic function that will call a distance function for each pair of accessions. It requires a dataframe of three columns: accession, marker, fragment length. It produces a full symmetric matrix. 
{
	data <- as.matrix(datain)
	acc <- unique(data[,1])
	numbacc <- length(acc)
	count <- 0
	totalloops <- (numbacc*numbacc)/2 - (numbacc/2)
	dd <- matrix(0, nrow = numbacc, ncol = numbacc) 
	for (i in 1:numbacc) 
	{
		d1 <- subset(data, data[,1] == acc[i])
		ii <- i + 1
		if (ii <= numbacc) 
		{
			for (j in ii:numbacc) 
			{
				d2 <- subset(data, data[,1] == acc[j])
				d <- get(paste("distance.",method,sep=""))(d1, d2)
				dd[j,i] <- d
				count <- count+1
			}
		}
	}
	rownames(dd) <- acc
	colnames(dd) <- acc
	dd <- as.dist(dd,diag = FALSE, upper = FALSE)
	return(dd)
}

distance <- function(data)
{
	distance.function.markers <- function(index.accession) 
	{
		distance.function.fragments <- function(index.accession,index.marker)
		{
			a.fragments <- data[,3][data[,1]==index.accession[1] & data[,2]==index.marker[1]]
			b.fragments <- data[,3][data[,1]==index.accession[2] & data[,2]==index.marker[2]]
			if (length(a.fragments)>0 & length(b.fragments)>0)
			{
				a.shared.proportion.fragments <- length(a.fragments %in% intersect(a.fragments,b.fragments))/length(a.fragments)
				b.shared.proportion.fragments <- length(b.fragments %in% intersect(a.fragments,b.fragments))/length(b.fragments)
				shared.proportion.fragments <- min(a.shared.proportion.fragments,b.shared.proportion.fragments)
			}
			else {shared.proportion.fragments <- 0}
			return(shared.proportion.fragments)
		}
		markers <- unique(c(data[,2][data[,1]==index.accession[1]],data[,2][data[,1]==index.accession[2]]))
		shared.proportion.mean.markers  <- mean(apply(cbind(rep(index.accession,times=length(markers))),1,function(x){distance.function.fragments(x[1:2],x[3])}))
		return(shared.proportion.mean.markers)
	}
	data <- na.omit(data)
	data <- subset(data,data[,3]>0)	
	accession.numbers <- unique(data[,1])
	index.accession <- cbind(rep(as.character(accession.numbers), each=length(accession.numbers)),rep(as.character(accession.numbers), times=length(accession.numbers)))
	distance.matrix <- matrix(0,ncol=length(accession.numbers),nrow=length(accession.numbers))
	rownames(distance.matrix) <- as.character(accession.numbers)
	colnames(distance.matrix) <- as.character(accession.numbers)
	distance.matrix[index.accession] <- distance.function.markers(apply(index.accession,1,distance.function.markers))
	return(distance.matrix)
}
			
distance.shared.proportion <- function(a,b)
{
	a <- as.data.frame(cbind(a[,2:3],rep(TRUE,times=length(a[,1]))))
	colnames(a)<-c("marker","fragment","a")
	b <- as.data.frame(cbind(b[,2:3],rep(TRUE,times=length(b[,1]))))
	colnames(b)<-c("marker","fragment","b")
	joined <- merge(a,b,all=T)
	joined <- cbind(joined,apply(joined[,3:4],1,function(x){min(x[1],x[2])}))
	agreement <- tapply(joined[,5],joined[,1],function(x){sum(x,na.rm=T)})
	proportion.a <- ifelse(agreement>0,agreement/tapply(as.logical(joined[,3]),joined[,1],function(x){sum(x,na.rm=T)}),0)
	proportion.b <- ifelse(agreement>0,agreement/tapply(as.logical(joined[,4]),joined[,1],function(x){sum(x,na.rm=T)}),0)
	shP <- (mean(pmin(proportion.a,proportion.b)))
	return(shP)
}

getformula <- function (vars, dummy) #Obsolete now
{
	v <- vector(length = 0, mode = "character")	
	for (i in 2:length(vars)) 
	{
		if (dummy[i-1] == 1) 
		{
			v <- c(v,vars[i]) 
		}
	}	
	f <- paste(vars[1], " ~ ",paste(v, collapse = " + "))
	return(as.formula(f))	
}

permregression.residual <- function (forml, permutations = 99) #Based on ter Braak
{
	forml <- as.formula(forml)
	reference.summary <- summary(lm(forml))
	N <- attributes(as.dist(get(as.character(forml[[2]]))))$Size	#rownames(attr(terms(forml,keep.order = TRUE), "factors"))[1]
	residuals <- reference.summary$residuals
	formterms <- rownames(attr(terms(forml,keep.order = TRUE), "factors"))[2:length(rownames(attr(terms(forml), "factors")))] #TODO: forml[[3]] would also do, I think
	begincoeff <- 2*(length(formterms)+1)+2
	endcoeff <- 3*(length(formterms)+1)	
	statistic <- c(reference.summary$r.squared,abs(reference.summary$coefficients[begincoeff:endcoeff])) #Reference statistic
	perm <- matrix(0, nrow = permutations, ncol = (length(formterms)+1))
	permformula <- as.formula(paste("permvec ~",paste(formterms, collapse="+"))) #
	for (i in 1:permutations) 
	{
		take <- sample(N,N)
		permvec <- as.dist(as.matrix(residuals)[take, take])
		permutation.summary <- summary(lm(permformula))
		perm[i,] <- as.vector(c(permutation.summary$r.squared,abs(permutation.summary$coefficients[begincoeff:endcoeff]))) #Reports the R2 and partial t's for each lm permutation
	}
	signif <- (rowSums(apply(perm,1,function(x){x>statistic}))+1)/(permutations+1)  #The "+1"s of the formula are due to Hope (1968) who added the reference value itself to the distribution to make the test slightly more "conservative" (Legendre et al. 1994). TODO use apply
	result <- list(permutations=permutations,r.squared=statistic[1],significance.r=signif[1],significance.terms=signif[2:length(signif)])
	return(result)
}

gsr <- function(Source, Search, Replace) #global search and replace (a normal replace doesn't work for dataframes) found on http://tolstoy.newcastle.edu.au/R/help/06/07/30503.html
{ 
	Changed <- as.character(Source) 
	for (i in 1:length(Search)) 
	{ 
		Changed <- replace(Changed, Changed == Search[i], Replace[i])   
	} 
	return(Changed) 
}

markerid <- as.vector(unique(genedata[,2]))
numberofmarkers <- length(markerid)
newmarkerid <- as.vector(c(1:numberofmarkers))
genedata[,2] <- gsr(genedata[,2], markerid, newmarkerid)

distmarker.test <- function(datain) #Generic function that will call a distance function for each pair of accessions. It requires a dataframe of three columns: accession, marker, fragment length. It produces a full symmetric matrix. 
{
	data <- as.matrix(datain)
	acc <- unique(data[,1])
	numbacc <- length(acc)
	count <- 0
	totalloops <- (numbacc*numbacc)/2 - (numbacc/2)
	dd <- matrix(0, nrow = numbacc, ncol = numbacc) 
	d1 <- subset(data, data[,1] == acc[1])
	d2 <- subset(data, data[,1] == acc[2])
	dd <- list(d1,d2)
	return(dd)
}

distsharedProportion <- function(a, b) #This calculates the -ln(shared proportion of alleles) based on the algorithm explained in the microsat programme
{
	spmarker <- 0
	markersa <- unique(a[,2])
	markersb <- unique(b[,2])
	markers <- intersect(markersa,markersb)
	markers <- subset(markers,markers>0) #This filters out missing markers, because they are set to -99
	for (d in 1:length(markers)) 
	{
		#Create two vectors with all fragments for one accession for one marker
		fragmentsa <- subset(a[,3], a[,2] == markers[d])
		fragmentsb <- subset(b[,3], b[,2] == markers[d])
		if (length(subset(fragmentsa,fragmentsa>0))>0 & length(subset(fragmentsb,fragmentsb>0))>0) #Filter out null/missing alleles
		{
			#Create a vector with the unique fragments from the total set of fragments from the two accessions
			fragments <- unique(c(fragmentsa,fragmentsb))
			fragments <- subset(fragments, fragments>0) #Null and missing alleles are not counted as contributing to similarity
			numberoffragments <- length(fragments)
			#Create two vectors that will be filled by the frequencies of the unique fragments
			fragmentfra <- vector(mode = "integer", length = numberoffragments)
			fragmentfrb <- vector(mode = "integer", length = numberoffragments)
			for (i in 1:numberoffragments) #For each fragment, calculate the number of times it is present in a and b respectively
			{
				for (k in 1:length(fragmentsa))
				{
					if (fragments[i] == fragmentsa[k]) {fragmentfra[i] <- fragmentfra[i]+(1/length(fragmentsa))}
				}
				for (l in 1:length(fragmentsb))
				{
					if (fragments[i] == fragmentsb[l]) {fragmentfrb[i] <- fragmentfrb[i]+(1/length(fragmentsb))}
				}
			}
			for (m in 1:numberoffragments) 	#Take the minimum of the relative frequency of each fragment and add them
			{
				spmarker <- spmarker+min(fragmentfra[m],fragmentfrb[m])
			}
		}
		#else {cat("Marker ", markers[d], " has missing values.","\n")}
	}
	sp <- (spmarker/length(markers))/(1-(spmarker/length(markers)))	#Divide accumulated shared proportion by the number of markers
	return(sp)
}

distsharedProportion3 <- function(a, b) #This calculates the -ln(shared proportion of alleles) based on the algorithm explained in the microsat programme
{
	spmarker <- 0
	nomarkers <- 0
	markers <- intersect(unique(a[,2]),unique(b[,2]))
	markers <- subset(markers,markers>0) #This filters out missing markers, because they are set to -99
	for (d in 1:length(markers)) 
	{
		#Create two vectors with all fragments for one accession for one marker
		
		fragmentsa <- subset(a[,3], a[,2] == markers[d] & a[,3]>0)
		fragmentsb <- subset(b[,3], b[,2] == markers[d] & b[,3]>0)
		if (length(fragmentsa)>0 & length(fragmentsb)>0)
		{
			#Create a vector with the unique fragments from the total set of fragments from the two accessions
			fragments <- intersect(fragmentsa,fragmentsb)
			if (length(fragments) > 0)
			{
				spmarker <- spmarker + sum(pmin(tabulate(match(fragmentsa, fragments))*1/length(fragmentsa),tabulate(match(fragmentsb, fragments))*1/length(fragmentsb))) 
			}
			nomarkers <- nomarkers + 1
		}
	}
	#else {cat("Marker ", markers[d], " has missing values.","\n")}
	sp <- (spmarker/nomarkers) #make linear by adding: /(1-(spmarker/nomarkers))	#Divide accumulated shared proportion by the number of markers
	return(sp)
}

connectedbuffer <- function(grid,adjacency,startvalue,factor,limit) #TODO Integrate "connected buffer" and "adjacencygrid"
{
	u <- unique(adjacency[,1]) #adjacency is a dense matrix containing all adjacency combinations twice (symmetric)
	select <- rbind(u, tabulate(match(adjacency[,1], u)))
	select <- subset(select[1,],select[2,]<4)
	growthborder <- unique(adjacency[,1][adjacency[,1] %in% select]) #selects cells on the coast 
	behindgrowthborder <- unique(adjacency[,2][adjacency[,1] %in% select]) #select cells behind the coast, to avoid growing towards land later on
	remove(select); remove(u)
	new <- matrix(nrow=4*length(growthborder),ncol=2)
	border <- unique(c(seq(1,(grid@ncols*grid@nrows-grid@ncols+1),by=grid@ncols),seq(grid@ncols,grid@ncols*grid@nrows,by=grid@ncols),1:grid@ncols,seq(grid@ncols*grid@nrows-grid@ncols+1,grid@ncols*grid@nrows,by=1)))
	for (i in 1:limit)
	{
		new[,1] <- rep(growthborder, times=4)
		new[,2] <- c((growthborder+1),(growthborder-1),(growthborder+grid@ncols),(growthborder-grid@ncols))
		new <- subset(new, new[,2] %in% setdiff(new[,2],c(growthborder,behindgrowthborder,border))) #Border (and land) nodes are excluded. This leaves the border free, but users may want to connect the borders. This can be achieved by inserting these connections separately.
		newcells <- unique(new[,2])
		mutual <- matrix(nrow=4*length(newcells),ncol=2)
		mutual[,1] <- rep(newcells, times=4)
		mutual[,2] <- c((newcells+1),(newcells-1),(newcells+grid@ncols),(newcells-grid@ncols))
		mutual <- subset(mutual, mutual[,2] %in% newcells)
		value <- rep(startvalue/factor^(i-1), times=length(mutual[,1])+length(new[,1]))
		buffer <- as.matrix(rbind(buffer,as.matrix(cbind(rbind(new,mutual),value))))
		behindgrowthborder <- growthborder
		growthborder <- newcells
		remove(new); remove(newcells)
		new <- matrix(nrow=length(growthborder)*4,ncol=2)
	}
	buffer <- na.omit(buffer)
	buffer <- rbind(buffer,cbind(buffer[,2],buffer[,1],buffer[,3]))
	buffer <- unique(buffer)
	return(buffer)
}

permregression.old <- function (forml, permutations = 99) #Based on Pierre Legendre, Francois-Joseph Lapointe and Philippe Casgrain. 1994. Modeling brain evolution from behavior: A permutational regression approach. Evolution 48(5),1487-1499)
{
	forml <- as.formula(forml)
	a <- summary(lm(forml))
	formterms <- rownames(attr(terms(forml,keep.order = TRUE), "factors"))[2:length(rownames(attr(terms(forml), "factors")))] #TODO: forml[[3]] would also do, I think
	begincoeff <- 2*(length(formterms)+1)+2
	endcoeff <- 3*(length(formterms)+1)	
	statistic <- c(a$r.squared,abs(a$coefficients[begincoeff:endcoeff])) #Reference statistic
	y <- as.dist(get(rownames(attr(terms(forml,keep.order = TRUE), "factors"))[1]))
	N <- attributes(y)$Size
	perm <- matrix(0, nrow = permutations, ncol = (length(formterms)+1))
	signif <- vector(length = length(formterms)+1)
	permformula <- as.formula(paste("permvec ~",paste(formterms, collapse="+"))) #
	for (i in 1:permutations) 
	{
		take <- sample(N,N)
		permvec <- as.dist(as.matrix(y)[take, take])
		a <- summary(lm(permformula))
		perm[i,] <- as.vector(c(a$r.squared,abs(a$coefficients[begincoeff:endcoeff]))) #Reports the R2 and partial t's for each lm permutation
	}
	for (j in 1:(length(formterms)+1)) #Calculate significance of R2 and t for each var.
	{
		signif[j] <- (length(perm[,j][perm[,j] >= statistic[j]]) + 1) /(permutations+1) #The "+1"s of the formula are due to Hope (1968) who added the reference value itself to the distribution to make the test slightly more "conservative" (Legendre et al. 1994). TODO use apply
	}
	result <- list(permutations=permutations,r.squared=statistic[1],significance.r=signif[1],significance.terms=signif[2:length(signif)])
	return(result)
}

Laplacian <- function(A) #This function works around the limitation of matrices with Dim > 46340.
{
	i <- 0:(A@Dim[1]-1)
	j <- 0:(A@Dim[1]-1)
	x <- colSums(A)
	Dim <- A@Dim[1]
	D <- new("dgTMatrix", i = as.integer(i), j = as.integer(j), x = as.numeric(x), Dim = as.integer(c(Dim,Dim)))
	L <- D-A
	return(as(L,"symmetricMatrix"))
}